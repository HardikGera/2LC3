# 2LC3
Finals

Week 12
Theorem “Idempotency of `G`”: (G G φ)  ≡≡  (G φ)
Proof:
  Using “LTL ≡≡”:
    For any `α`, `t`:
        ⟦ (G φ) ⟧ α t
      ≡⟨ “Semantics of `G`” ⟩
        ∀ t′ : ℕ ❙ t ≤ t′ • ⟦ φ ⟧ α t′
      ≡⟨ ?, “Trading for ∀”⟩
        ∀ t′′ : ℕ • t ≤ t′′ ⇒ ⟦ φ ⟧ α t′
      ≡⟨ “Highvalue”⟩ 
        ∀ t′′ : ℕ • (∃ t′ : ℕ • t ≤ t′ ≤ t′′) ⇒ ⟦ φ ⟧ α t′′
      ≡⟨ “Witness” ⟩ 
        ∀ t′′ : ℕ • ∀ t′ : ℕ • t ≤ t′ ≤ t′′ ⇒ ⟦ φ ⟧ α t′′
      ≡⟨ “Trading for ∀” ⟩ 
        ∀ t′′ : ℕ • ∀ t′ : ℕ ❙ t ≤ t′ • t′ ≤ t′′ ⇒ ⟦ φ ⟧ α t′′
      ≡⟨ “Interchange of dummies for ∀” ⟩
        ∀ t′ : ℕ ❙ t ≤ t′ • ∀ t′′ : ℕ • t′ ≤ t′′ ⇒ ⟦ φ ⟧ α t′′
      ≡⟨“Trading for ∀” ⟩ 
        ∀ t′ : ℕ ❙ t ≤ t′ • ∀ t′′ : ℕ ❙ t′ ≤ t′′ • ⟦ φ ⟧ α t′′
      ≡⟨ “Semantics of `G`”⟩ 
        ∀ t′ : ℕ ❙ t ≤ t′ • ⟦ G φ ⟧ α t′
      ≡⟨ “Semantics of `G`” ⟩
        ⟦ (G G φ) ⟧ α t


Theorem “B via U”: (φ B ψ)  ≡≡  (¬′ ((¬′ φ) U ψ))
Proof:
  Using “LTL ≡≡”:
    For any `α`, `t`:
        ⟦ (φ B ψ) ⟧ α t
      ≡⟨ “Semantics of `B`”⟩
        ∀ t′ : ℕ ❙ t ≤ t′
              • ⟦ ψ ⟧ α t′
              ⇒ ∃ t″ : ℕ ❙ t ≤ t″ < t′ • ⟦ φ ⟧ α t″
      ≡⟨ “Trading for ∀” ⟩
        ∀ t′ : ℕ ❙ t ≤ t′
              ∧ ⟦ ψ ⟧ α t′
              • ∃ t″ : ℕ ❙ t ≤ t″ < t′ • ⟦ φ ⟧ α t″
      ≡⟨ “Generalised De Morgan” ⟩
        ¬ ∃ t′ : ℕ ❙ t ≤ t′
              ∧ ⟦ ψ ⟧ α t′
              • ∀ t″ : ℕ ❙ t ≤ t″ < t′ • ¬ ⟦ φ ⟧ α t″
      ≡⟨ “Trading for ∃”, “Semantics of LTL ¬”⟩
        ¬ ∃ t′ : ℕ ❙ t ≤ t′
              • ⟦ ψ ⟧ α t′
              ∧ ∀ t″ : ℕ ❙ t ≤ t″ < t′ • ⟦ ¬′ φ ⟧ α t″
      ≡⟨ “Semantics of `U`” ⟩
        ¬ ⟦ (¬′ φ) U ψ ⟧ α t
      ≡⟨ “Semantics of LTL ¬”⟩
        ⟦ (¬′ ((¬′ φ) U ψ)) ⟧ α t



Theorem “Negation of X”: (¬′ X φ)  ≡≡  (X ¬′ φ)
Proof:
  Using “LTL ≡≡”:
    For any `α`, `t`:
        ⟦ (¬′ X φ) ⟧ α t
      ≡⟨“Semantics of LTL ¬”⟩
        ¬ ⟦ X φ ⟧ α t
      ≡⟨“Semantics of `X`”⟩
        ¬ (⟦ φ ⟧ α) (suc t)
      ≡⟨“Semantics of LTL ¬”⟩
        ( ⟦ ¬′  φ ⟧ α) (suc t)
      ≡⟨“Semantics of `X`”⟩
        ⟦ (X ¬′ φ) ⟧ α t



Theorem “V via B”: (φ V ψ)  ≡≡  (φ B ¬′ ψ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ (φ V ψ) ⟧ α t
      ≡⟨“Semantics of V”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ ∧ ¬ ⟦ ψ ⟧ α t′ • ∃ t″ ❙ t ≤ t″ < t′ • ⟦ φ ⟧ α t″)
      ≡⟨“Trading for ∀”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • ¬ (⟦ ψ ⟧ α) t′ ⇒ (∃ t″ : ℕ ❙ t ≤ t″ < t′ • (⟦ φ ⟧ α) t″ ) )   
      ≡⟨“Semantics of LTL ¬”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ (¬′ ψ) ⟧ α) t′ ⇒ (∃ t″ : ℕ ❙ t ≤ t″ < t′ • (⟦ φ ⟧ α) t″ ) )   
      ≡⟨“Semantics of B”⟩
        ⟦ (φ B ¬′ ψ) ⟧ α t


╍╍╍ Axiom “Semantics of B”: (⟦ (φ B ψ) ⟧ α) t ≡ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ ψ ⟧ α) t′ ⇒ (∃ t″ : ℕ ❙ t ≤ t″ < t′ • (⟦ φ ⟧ α) t″ ) )   
╍╍╍ Axiom “Semantics of LTL ¬”: (⟦ (¬′ φ) ⟧ α) t ≡ ¬ (⟦ φ ⟧ α) t


Lemma “Semantics of Y”:
    ⟦ Y φ ⟧ α t ≡ t ≠ 0 ∧ ⟦ φ ⟧ α (pred t)
Proof:
  By induction on t : ℕ:
    Base case:
        ⟦ Y φ ⟧ α 0 
      ≡⟨“Semantics of Y”⟩
        false
      ≡⟨“Irreflexivity of ≠”, “Zero of ∧”⟩
        0 ≠ 0 ∧ ⟦ φ ⟧ α (pred 0)
    Induction step:
        ⟦ Y φ ⟧ α (suc t)
      ≡⟨“Semantics of Y”⟩
        ⟦ φ ⟧ α t
      ≡⟨“Identity of ∧”⟩
        true ∧ ⟦ φ ⟧ α t
      ≡⟨“Zero is not successor”⟩
        (suc t) ≠ 0 ∧ ⟦ φ ⟧ α t
      ≡⟨“Predecessor of successor”⟩
        suc t ≠ 0 ∧ ⟦ φ ⟧ α (pred (suc t))


Lemma “Semantics of Z”:
    ⟦ Z φ ⟧ α t  ≡  t = 0 ∨ ⟦ φ ⟧ α (pred t)
Proof:
  By induction on t : ℕ:
    Base case:
        ⟦ Z φ ⟧ α 0 
      ≡⟨“Semantics of Z”⟩ 
        true
      ≡⟨“Zero of ∨”, “Reflexivity of =”⟩
        0 = 0 ∨ ⟦ φ ⟧ α (pred 0)
    Induction step:
        ⟦ Z φ ⟧ α (suc t)
      ≡⟨“Semantics of Z”⟩
        ⟦ φ ⟧ α t
      ≡⟨“Identity of ∨”⟩
        false ∨ ⟦ φ ⟧ α t
      ≡⟨“Zero is not successor”⟩
        (suc t) = 0 ∨ ⟦ φ ⟧ α t
      ≡⟨“Predecessor of successor”⟩
        (suc t) = 0 ∨ ⟦ φ ⟧ α (pred (suc t))


Theorem “Reflexivity of LTL ≡≡”: φ ≡≡ φ
Proof:
    φ ≡≡ φ 
  ≡⟨“LTL ≡≡”⟩
    (∀ α : A → ℕ → 𝔹 • ∀ t : ℕ • ⟦ φ ⟧ α t ≡ ⟦ φ ⟧ α t)
  ≡⟨“Reflexivity of ≡”⟩ 
    (∀ α : A → ℕ → 𝔹 • ∀ t : ℕ • true)
  ≡⟨“True ∀ body”⟩
    true


Theorem “Symmetry of LTL ≡≡”: φ ≡≡ ψ  ≡  ψ ≡≡ φ
Proof:
    φ ≡≡ ψ
  ≡⟨“LTL ≡≡”⟩
    ∀ α : A → ℕ → 𝔹 • ∀ t : ℕ • ⟦ φ ⟧ α t ≡ ⟦ ψ ⟧ α t
  ≡⟨“Symmetry of ≡”⟩
    ∀ α : A → ℕ → 𝔹 • ∀ t : ℕ • ⟦ ψ ⟧ α t ≡ ⟦ φ ⟧ α t 
  ≡⟨“LTL ≡≡”⟩
    ψ ≡≡ φ


Theorem “Transitivity of LTL ≡≡”: φ ≡≡ χ ≡≡ ψ  ⇒  φ ≡≡ ψ
Proof:
  Assuming φ ≡≡ χ ∧ χ ≡≡ ψ and using with “LTL ≡≡”: 
    Using “LTL ≡≡”:
      For any α, t:
          ⟦ φ ⟧ α t
        ≡⟨ Assumption φ ≡≡ χ ∧ χ ≡≡ ψ⟩
          ⟦ χ ⟧ α t
        ≡⟨ Assumption φ ≡≡ χ ∧ χ ≡≡ ψ⟩
          ⟦ ψ ⟧ α t

Lemma “Symmetry of LTL ∧”:  (φ ∧′ ψ) ≡≡ (ψ ∧′ φ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ φ ∧′ ψ ⟧ α t ≡ ⟦ ψ ∧′ φ ⟧ α t
      ≡⟨“Semantics of LTL ∧”, “Symmetry of ∧”, “Reflexivity of ≡”⟩
        true


Lemma “Symmetry of LTL ∨”:  (φ ∨′ ψ) ≡≡ (ψ ∨′ φ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ φ ∨′ ψ ⟧ α t ≡ ⟦ ψ ∨′ φ ⟧ α t
      ≡⟨“Semantics of LTL ∨”, “Symmetry of ∨”, “Reflexivity of ≡”⟩
        true


Lemma “Symmetry of LTL ⇔”:  (φ ⇔′ ψ) ≡≡ (ψ ⇔′ φ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ φ ⇔′ ψ ⟧ α t ≡ ⟦ ψ ⇔′ φ ⟧ α t
      ≡⟨“Semantics of LTL ⇔”, “Reflexivity of ≡”⟩
        true

Lemma “Associativity of LTL ∧”:
  ((φ ∧′ ψ) ∧′ χ) ≡≡ (φ ∧′ (ψ ∧′ χ))
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ ((φ ∧′ ψ) ∧′ χ) ⟧ α t
      ≡⟨“Semantics of LTL ∧”⟩
        ⟦ (φ ∧′ ψ) ⟧ α t ∧ ⟦ χ ⟧ α t
      ≡⟨“Semantics of LTL ∧”⟩
        ⟦ φ ⟧ α t ∧ ⟦ ψ ⟧ α t ∧ ⟦ χ ⟧ α t
      ≡⟨ “Symmetry of ∧”⟩
        ⟦ φ ⟧ α t ∧ ( ⟦ ψ ⟧ α t ∧ ⟦ χ ⟧ α t )
      ≡⟨ “Semantics of LTL ∧”⟩
        ⟦ φ ⟧ α t ∧ ⟦ (ψ ∧′ χ) ⟧ α t
      ≡⟨ “Semantics of LTL ∧”⟩
        ⟦ (φ ∧′ (ψ ∧′ χ)) ⟧ α t


Lemma “Absorption of LTL ∨ by ∧”:
  (φ ∧′ (φ ∨′ ψ)) ≡≡ φ
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ (φ ∧′ (φ ∨′ ψ)) ⟧ α t
      ≡⟨“Semantics of LTL ∧”⟩
        ⟦ φ ⟧ α t ∧ ⟦ (φ ∨′ ψ) ⟧ α t
      ≡⟨“Semantics of LTL ∨”⟩
        ⟦ φ ⟧ α t ∧ (⟦ φ ⟧ α t ∨ ⟦ ψ ⟧ α t)
      ≡⟨“Absorption”⟩
        ⟦ φ ⟧ α t


Theorem “Negation of X”: (¬′ X φ)  ≡≡  (X ¬′ φ)
Proof:  
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ (¬′ X φ) ⟧ α t
      ≡⟨“Semantics of LTL ¬”⟩
        ¬ ⟦ X φ ⟧ α t
      ≡⟨“Semantics of X”⟩
        ¬ (⟦ φ ⟧ α) (suc t)
      ≡⟨“Semantics of LTL ¬”⟩
        ( ⟦ ¬′  φ ⟧ α) (suc t)
      ≡⟨“Semantics of X”⟩
        ⟦ (X ¬′ φ) ⟧ α t
        

╍╍╍ Axiom “Semantics of X”: (⟦ (X φ) ⟧ α) t ≡ (⟦ φ ⟧ α) (suc t)
╍╍╍ Axiom “Semantics of LTL ¬”: ⟦ ¬′ φ ⟧ α t ≡ ¬ ⟦ φ ⟧ α t


Theorem “G via F”: (G φ)  ≡≡  (¬′ F ¬′ φ)
Proof:
  Using “LTL ≡≡”: 
    For any α, t:
        ⟦ (G φ) ⟧ α t
      ≡⟨“Semantics of G”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      ≡⟨“Generalised De Morgan”⟩
        ¬ (∃ t′ : ℕ ❙ t ≤ t′ • ¬ (⟦ φ ⟧ α) t′ )
      ≡⟨“Semantics of LTL ¬”⟩  
        ¬ (∃ t′ : ℕ ❙ t ≤ t′ • (⟦ ¬′ φ ⟧ α) t′ )
      ≡⟨“Semantics of F”⟩
        ¬ ⟦ (F ¬′ φ) ⟧ α t
      ≡⟨“Semantics of LTL ¬”⟩
        ⟦ (¬′ F ¬′ φ) ⟧ α t


Theorem “V via B”: (φ V ψ)  ≡≡  (φ B ¬′ ψ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ (φ V ψ) ⟧ α t
      ≡⟨“Semantics of V”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ ∧ ¬ ⟦ ψ ⟧ α t′ • ∃ t″ ❙ t ≤ t″ < t′ • ⟦ φ ⟧ α t″)
      ≡⟨“Trading for ∀”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • ¬ (⟦ ψ ⟧ α) t′ ⇒ (∃ t″ : ℕ ❙ t ≤ t″ < t′ • (⟦ φ ⟧ α) t″ ) )   
      ≡⟨“Semantics of LTL ¬”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ (¬′ ψ) ⟧ α) t′ ⇒ (∃ t″ : ℕ ❙ t ≤ t″ < t′ • (⟦ φ ⟧ α) t″ ) )   
      ≡⟨“Semantics of B”⟩
        ⟦ (φ B ¬′ ψ) ⟧ α t

Theorem “G via V”: (G φ)  ≡≡  (FALSE V φ)
Proof:
  Using “LTL ≡≡”:
    For any α, t:
        ⟦ (G φ) ⟧ α t
      =⟨“Semantics of G”⟩
        (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“Identity of ∨”⟩
        false ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨ “Double negation”, “Negation of false”⟩
        ¬ ( true )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“True ∀ body”⟩ 
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • ( true ) )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“Zero of ∨”⟩
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • ( true ∨ ¬(∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“Negation of false”⟩
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • (¬ false ∨ ¬(∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“De Morgan”⟩
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • ¬ (false ∧ (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • (⟦ φ ⟧ α) t′ )
      =⟨“Identity of ∧”⟩
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • ¬ (false ∧ (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) )
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • true ∧ (⟦ φ ⟧ α) t′ )
      =⟨“Generalised De Morgan”⟩
        ¬ (∀ t″ : ℕ ❙ t ≤ t″ • ¬ (false ∧ (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) )
        ∨ ¬ (∃ t′ : ℕ ❙ t ≤ t′ • ¬ (true ∧ (⟦ φ ⟧ α) t′) )
      =⟨“Generalised De Morgan”⟩
        (∃ t″ : ℕ ❙ t ≤ t″ • false ∧ 
        (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) 
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • true
        ∧ (⟦ φ ⟧ α) t′ )
      =⟨“Negation of false”⟩
        (∃ t″ : ℕ ❙ t ≤ t″ • false ∧ 
        (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) 
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • ¬ false
        ∧ (⟦ φ ⟧ α) t′ )
      =⟨“Semantics of FALSE”⟩
        (∃ t″ : ℕ ❙ t ≤ t″ • (⟦ FALSE ⟧ α) t″ ∧ 
        (∀ t′ : ℕ ❙ t ≤ t′ ≤ t″ • (⟦ φ ⟧ α) t′ ) ) 
        ∨ (∀ t′ : ℕ ❙ t ≤ t′ • ¬ (⟦ FALSE ⟧ α) t′ 
        ∧ (⟦ φ ⟧ α) t′ )   
      =⟨“Semantics of V”⟩
        ⟦ FALSE V φ ⟧ α t


While loop

Theorem “Adding₁”:
      n = n₀
    ⇒⁅  i := 0 ⍮
        while i ≠ m
          do
            i := i + 1 ⍮
            n := n + 1
          od
      ⁆
      n = m + n₀
Proof:
    n = n₀
  ≡⟨“Identity of +”⟩
    n = n₀ + 0
  ⇒⁅ i := 0 ⁆ ⟨“Assignment” with Substitution⟩
    n = i + n₀ 
  


  ⇒⁅ 
        while i ≠ m
          do
            i := i + 1 ⍮
            n := n + 1
          od
      ⁆
   ⟨ “While” with subproof:
         ( i ≠ m ) ∧ (n = i + n₀ )
       ⇒⟨“Weakening”⟩
         n = i + n₀  
       ≡⟨“Cancellation of +”⟩
         n + 1 = i + n₀ + 1
       ⇒⁅ i := i + 1 ⁆ ⟨“Assignment” with Substitution⟩ 
         n + 1 = i + n₀ 
       ⇒⁅ n := n + 1 ⁆ ⟨“Assignment” with Substitution⟩
         n = i + n₀
    ⟩

    ¬ ( i ≠ m) ∧ (n = n₀ + i )
  ≡⟨“Definition of ≠”⟩
    ¬ ¬ ( i = m) ∧ (n = n₀ + i )
  ≡⟨“Double negation”⟩
    (i = m) ∧ (n = n₀ + i )
  ≡⟨ Substitution ⟩
    (i = m) ∧ (n = n₀ + z ) [z ≔ i]
  ≡⟨ “Replacement” ⟩ 
    (i = m) ∧ (n = n₀ + z ) [z ≔ m]
  ≡⟨ Substitution ⟩
    (i = m) ∧ (n = n₀ + m )
  ⇒⟨ “Weakening”⟩
    n = m + n₀


Theorem “Adding₂”:
      m = m₀ ∧ n = n₀
    ⇒⁅  while m ≠ 0
          do
            m := m - 1 ⍮
            n := n + 1
          od
      ⁆
      n = m₀ + n₀
Proof:
    m = m₀ ∧ n = n₀
  =⟨ “Cancellation of +” ⟩
    m + n = m₀ + n ∧ n = n₀
  =⟨ Substitution  ⟩
    (m + n = m₀ + z) [z ≔ n]  ∧ n = n₀ 
  =⟨ “Replacement” ⟩
    (m + n = m₀ + z) [z ≔ n₀]  ∧ n = n₀  
  =⟨ Substitution ⟩  
    (m + n = m₀ + n₀) ∧   n = n₀  
  ⇒⟨ “Weakening” ⟩ 
    m + n = m₀ + n₀ 
  ⇒⁅  while m ≠ 0
          do
            m := m - 1 ⍮
            n := n + 1
          od
      ⁆
   ⟨“While” with subproof:
        m ≠ 0 ∧ (m + n = m₀ + n₀)
      ⇒⟨ “Weakening”⟩ 
        m + n = m₀ + n₀
      =⟨“Identity of +”⟩
        m + n + 0 = m₀ + n₀  
      =⟨ Fact `1 - 1 = 0` ⟩
        m + n + ( 1 - 1 ) = m₀ + n₀ 
      =⟨ “Subtraction” ⟩  
        m + n + 1 + ( - 1 ) = m₀ + n₀
      =⟨ “Symmetry of +”⟩
        m + (- 1) + n + 1 = m₀ + n₀
      =⟨ “Subtraction”⟩
        m - 1 + n + 1 = m₀ + n₀
      ⇒⁅ m := m - 1 ⁆⟨ “Assignment” with Substitution⟩ 
        m + n + 1 = m₀ + n₀
      ⇒⁅ n := n + 1 ⁆⟨ “Assignment” with Substitution⟩ 
        m + n = m₀ + n₀
    ⟩


    ¬ ( m ≠ 0) ∧ (m + n = m₀ + n₀)
  ≡⟨“Definition of ≠”⟩
    ¬ ¬( m = 0) ∧ (m + n = m₀ + n₀)
  ≡⟨“Double negation”⟩ 
    ( m = 0) ∧ (m + n = m₀ + n₀)
  ≡⟨ Substitution⟩
    ( m = 0) ∧ (i + n = m₀ + n₀)[ i ≔ m]
  ≡⟨ “Replacement”⟩
    ( m = 0) ∧ (i + n = m₀ + n₀)[ i ≔ 0]
  ≡⟨ Substitution⟩
    ( m = 0) ∧ (0 + n = m₀ + n₀)
  ≡⟨“Identity of +”⟩
    ( m = 0) ∧ (n = m₀ + n₀)
  ⇒⟨“Weakening”⟩
    n = m₀ + n₀



11.2

Theorem “Membership in ‥”:  i ∈ m ‥ n  ≡  m ≤ i ≤ n
Proof:
    i ∈ m ‥ n
  =⟨ “Definition of ‥” ⟩
    i ∈ { i ❙ m ≤ i ≤ n }
  =⟨ “Simple membership” ⟩ 
    m ≤ i ≤ n

Theorem “Membership in 0 ‥”:  i ∈ 0 ‥ n  ≡  i ≤ n
Proof:
    i ∈ 0 ‥ n
  =⟨ “Definition of ‥” ⟩
    i ∈ { i ❙ 0 ≤ i ≤ n }
  =⟨ “Simple membership” ⟩
    0 ≤ i ≤ n
  =⟨ “Reflexivity of ≡” ⟩
    0 ≤ i ∧ i ≤ n
  =⟨ “Zero is least element”⟩
    true ∧ i ≤ n
  =⟨ “Identity of ∧”⟩
    i ≤ n

Theorem “Sorting 0′”:
    xs₀ = xs ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟
  ⇒⁅ while true do
        xs := xs ⊕ { ⟨ 0, 42 ⟩ }
      od
    ⁆
    xs ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟  ∧  sorted xs
      ∧ (∃ f ❙ f ∈ (0 ‥ k) ⤖ (0 ‥ k) • xs = f ⨾ xs₀)
Proof:
    xs₀ = xs ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟
  ⇒⟨ “Right-zero of ⇒” ⟩
    true                        ╍╍╍ Invariant
  ⇒⁅ while true do
        xs := xs ⊕ { ⟨ 0, 42 ⟩ }
      od
    ⁆ ⟨ “While” with subproof:
            true ∧ true
          =⟨ “Identity of ∧” ⟩
            true
          ⇒⁅ xs := xs ⊕ { ⟨ 0, 42 ⟩ } ⁆ ⟨ “Assignment” with substitution ⟩
            true
    ⟩
    ¬ true ∧ true
  =⟨ “Definition of `false`” ⟩
    false ∧ true
  =⟨ “Identity of ∧” ⟩
    false
  ⇒⟨ “ex falso quodlibet” ⟩
    xs ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟  ∧  sorted xs
      ∧ (∃ f ❙ f ∈ (0 ‥ k) ⤖ (0 ‥ k) • xs = f ⨾ xs₀)


Theorem “Array swap”:
       i ≤ k ≥ j  ∧  xs = xs₀ ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟
    ⇒⁅ z := xs @ i ⍮
       xs := xs ⊕ { ⟨ i, xs @ j ⟩ } ⍮
       xs := xs ⊕ { ⟨ j, z ⟩ }
     ⁆
      xs = xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
Proof:
      xs = xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
  ⁅ xs := xs ⊕ { ⟨ j, z ⟩ } ⁆⇐ ⟨ “Assignment” with substitution ⟩
      xs ⊕ { ⟨ j, z ⟩ } = xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
  ⁅ xs := xs ⊕ { ⟨ i, xs @ j ⟩ } ⁆⇐ ⟨ “Assignment” with substitution ⟩
      (xs  ⊕ { ⟨ i, xs @ j ⟩ }) ⊕ { ⟨ j, z ⟩ } = xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
  ⁅ z := xs @ i ⁆⇐ ⟨ “Assignment” with substitution ⟩
      (xs  ⊕ { ⟨ i, xs @ j ⟩ }) ⊕ { ⟨ j, xs @ i ⟩ } = xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
  ⇐⟨ Subproof:
      Assuming (1) `i ≤ k ≥ j  ∧  xs = xs₀ ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟`:
        By cases: `i = j`, `¬ (i = j)`
          Completeness: By “LEM”
          Case `i = j`:
              (xs  ⊕ { ⟨ i, xs @ j ⟩ }) ⊕ { ⟨ j, xs @ i ⟩ }
            =⟨ Assumption `i = j` ⟩
              (xs  ⊕ { ⟨ i, xs @ i ⟩ }) ⊕ { ⟨ i, xs @ i ⟩ }
            =⟨ “Repeated ⊕”, assumption (1) ⟩
              xs₀ ⊕ { ⟨ i , xs₀ @ i ⟩ }
            =⟨ “Idempotency of ∨” ⟩
              xs₀ ⊕ { ⟨ i , xs₀ @ i ⟩, ⟨ i , xs₀ @ i ⟩ }
            =⟨ Assumption `i = j` ⟩
              xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
          Case `¬ (i = j)`:
              (xs  ⊕ { ⟨ i, xs @ j ⟩ }) ⊕ { ⟨ j, xs @ i ⟩ }
            =⟨ “Associativity of ⊕” ⟩
              xs  ⊕ ({ ⟨ i, xs @ j ⟩ } ⊕ { ⟨ j, xs @ i ⟩ })
            =⟨ “Singletons ⊕” with assumption `¬ (i = j)`, assumption (1) ⟩
              xs₀ ⊕ { ⟨ i , xs₀ @ j ⟩, ⟨ j , xs₀ @ i ⟩ }
    ⟩
    i ≤ k ≥ j  ∧  xs = xs₀ ∈ (0 ‥ k) ⇴ ⌞ ℕ ⌟


11.1

Theorem (KA.36) “Idempotency of *”:  R * * = R *
Proof:
    R *
  ⊆⟨ “* increases” ⟩ 
    R * *
  =⟨ “Identity of ⨾” ⟩
    R * * ⨾ 𝕀
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    R * * ⨾ R *
  ⊆⟨ Subproof for `R * * ⨾ R * ⊆ R *`: 
       Using “Left-induction for *”:
         Subproof for `R * ⨾ R * ⊆ R *`:
           By “Transitivity of *” 
    ⟩
    R *

Theorem (KA.34) “Left-induction with ∪ for *”:
    R ⨾ S ∪ T ⊆ S  ⇒  R * ⨾ T ⊆ S
Proof:
  Assuming (1) `R ⨾ S ∪ T ⊆ S`
    and using with “Characterisation of ∪”:
      R * ⨾ T
    ⊆⟨ Monotonicity with Assumption (1)⟩
      R * ⨾ S
    ⊆⟨ Subproof for `R * ⨾ S ⊆ S`:
         Using “Left-induction for *”:
           Subproof for `R ⨾ S ⊆ S`:
             By Assumption (1) 
      ⟩ 
      S

Theorem (KA.32) “Refl-trans closure minimality”:
    R ⊆ S  ∧  reflexive S  ∧  transitive S  ⇒  R * ⊆ S
Proof:
  Assuming `R ⊆ S`,
           (1) `reflexive S` and using with “Definition of reflexivity”,
           (2) `transitive S` and using with “Definition of transitivity”:
      R *  
    ⊆⟨ Monotonicity with Assumption `R ⊆ S` ⟩
      S *
    =⟨ “Refl-trans *” with Assumption (1) and Assumption (2)⟩
      S

Theorem (KA.31) “Refl-trans *”:
  reflexive R  ∧  transitive R  ⇒  R * = R
Proof:
  Assuming (1) `reflexive R` and using with “Definition of reflexivity”,
           (2) `transitive R` and using with “Definition of transitivity”:
      R
    ⊆⟨ “* increases” ⟩
      R *
    =⟨ “Identity of ⨾” ⟩
      R * ⨾ 𝕀
    ⊆⟨ Monotonicity with Assumption (1) ⟩
      R * ⨾ R 
    ⊆⟨ Subproof for `R * ⨾ R ⊆ R`: 
         Using “Left-induction for *”:
           Subproof for `R ⨾ R ⊆ R`:
             By Assumption (2)
      ⟩
      R  

Theorem (KA.30) “Subidentity *”: R ⊆ 𝕀  ⇒  R * = 𝕀
Proof:
  Assuming `R ⊆ 𝕀`:
    Using “Mutual inclusion”:
      Subproof for `𝕀 ⊆ R *`:
          𝕀
        ⊆⟨ “Reflexivity of *”⟩
          R *
      Subproof for `R * ⊆ 𝕀`:
          R * ⊆ 𝕀
        =⟨ “Identity of ⨾” ⟩
          R * ⨾ 𝕀 ⊆ 𝕀
        ⇐⟨ “Left-induction for *” ⟩
          R ⨾ 𝕀 ⊆ 𝕀
        =⟨ “Identity of ⨾” ⟩
          R ⊆ 𝕀

Theorem (KA.28) “Reflexive closure *”: (𝕀 ∪ R) * = R *
Proof:
    R *
  ⊆⟨ Monotonicity with “Weakening for ∪”⟩
    (R ∪ 𝕀) *
  =⟨ “Union *” ⟩
    (R * ⨾ 𝕀) * ⨾ R *
  =⟨ “Identity of ⨾” ⟩
    R * * ⨾ R *
  ⊆⟨ Monotonicity with “Subproof1”⟩
    R * ⨾ R *
  =⟨ “⨾-idempotency of *”⟩
    R *

Lemma “Subproof1”: R * * ⊆ R *
Proof:
    R * *
  =⟨ “Identity of ⨾” ⟩
    R * * ⨾ 𝕀
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    R * * ⨾ R *
  ⊆⟨ Subproof for `R * * ⨾ R * ⊆ R *`: 
       Using “Left-induction for *”:
         Subproof for `R * ⨾ R * ⊆ R *`:
           By “Transitivity of *” 
    ⟩
    R *

Theorem (KA.27) “Composition *”:  (R ⨾ S) * = 𝕀 ∪ R ⨾ (S ⨾ R) * ⨾ S
Proof:
    (R ⨾ S) *
  =⟨ “Left-iteration for *” ⟩
    𝕀 ∪ R ⨾ S ⨾ (R ⨾ S) *
  =⟨ “Composition * shifting” ⟩
    𝕀 ∪ R ⨾ (S ⨾ R) * ⨾ S

Theorem (KA.26) “Composition * shifting”: (R ⨾ S) * ⨾ R = R ⨾ (S ⨾ R) *
Proof:
    (R ⨾ S) * ⨾ R
  =⟨ “Identity of ⨾” ⟩
    (R ⨾ S) * ⨾ R ⨾ 𝕀
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    (R ⨾ S) * ⨾ R ⨾ (S ⨾ R) *
  ⊆⟨Subproof for `(R ⨾ S) * ⨾ R ⨾ (S ⨾ R) * ⊆ R ⨾ (S ⨾ R) *`: 
      Using “Left-induction for *”:
        Subproof for `(R ⨾ S) ⨾ R ⨾ (S ⨾ R) * ⊆ R ⨾ (S ⨾ R) *`:
              (R ⨾ S) ⨾ R ⨾ (S ⨾ R) *
            ⊆⟨ Monotonicity with “Left-iteration ⊆ in *” ⟩ 
              R ⨾ (S ⨾ R) *


    ⟩

    R ⨾ (S ⨾ R) * 
  =⟨ “Identity of ⨾” ⟩
    𝕀 ⨾ R ⨾ (S ⨾ R) * 
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    (R ⨾ S) * ⨾ R ⨾ (S ⨾ R) *
  ⊆⟨ Subproof for `(R ⨾ S) * ⨾ R ⨾ (S ⨾ R) * ⊆ (R ⨾ S) * ⨾ R`:
       Using “Right-induction for *”:
         Subproof for `(R ⨾ S) * ⨾ R ⨾ (S ⨾ R) ⊆ (R ⨾ S) * ⨾ R`:
                 (R ⨾ S) * ⨾ R ⨾ S ⨾ R
              ⊆⟨ Monotonicity with “Right-iteration ⊆ in *”⟩
                 (R ⨾ S) * ⨾ R
    ⟩
    (R ⨾ S) * ⨾ R

Theorem (KA.22) “Subidentity decomposition entering * from left”:
    G ⨾ F ⊆ 𝕀
  ⇒ (F ⨾ R ⨾ G) * ⨾ F ⊆ F ⨾ R *
Proof:
  Assuming `G ⨾ F ⊆ 𝕀`:
      (F ⨾ R ⨾ G) * ⨾ F
    =⟨“Identity of ⨾”⟩
      (F ⨾ R ⨾ G) * ⨾ F ⨾ 𝕀
    ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
      (F ⨾ R ⨾ G) * ⨾ F ⨾ R *
    ⊆⟨ Subproof for `(F ⨾ R ⨾ G) * ⨾ F ⨾ R * ⊆ F ⨾ R *`:
        Using “Left-induction for *”:
          Subproof for `F ⨾ R ⨾ G ⨾ F ⨾ R * ⊆ F ⨾ R *`:
              F ⨾ R ⨾ G ⨾ F ⨾ R *
            ⊆⟨Monotonicity with Assumption `G ⨾ F ⊆ 𝕀`⟩ 
              F ⨾ R ⨾ 𝕀 ⨾ R *
            =⟨ “Identity of ⨾”⟩ 
              F ⨾ R ⨾ R *
            ⊆⟨ Monotonicity with “Left-iteration ⊆ in *”⟩ 
              F ⨾ R *
      ⟩
      F ⨾ R *

  Assuming `R ⊆ S`:
      R *
    =⟨ “Identity of ⨾”⟩
      R * ⨾ 𝕀
    ⊆⟨ Monotonicity with “Reflexivity of *”⟩
      R * ⨾ S *
    ⊆⟨ Subproof for `R * ⨾ S * ⊆ S *`:
         Using “Left-induction for *”:
           Subproof for `R ⨾ S * ⊆ S *`:
               R ⨾ S *
             ⊆⟨ Monotonicity with Assumption `R ⊆ S` ⟩
               S ⨾ S *
             ⊆⟨ “Left-iteration ⊆ in *” ⟩
               S *  
      ⟩  
      S *

Theorem (KA.14) “Shuffle *”:  R ⨾ R * = R * ⨾ R
Proof:
    R ⨾ R *
  =⟨ “Identity of ⨾” ⟩
    𝕀 ⨾ R ⨾ R * 
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    R * ⨾ R ⨾ R *
  ⊆⟨ “Right-induction for *” with 
        Subproof for `R * ⨾ R ⨾ R ⊆ R * ⨾ R`:
            R * ⨾ R ⨾ R
          ⊆⟨ Monotonicity with “Right-iteration ⊆ in *” ⟩
            R * ⨾ R 
    ⟩ 
    R * ⨾ R
  =⟨ “Identity of ⨾” ⟩
    R * ⨾ R ⨾ 𝕀
  ⊆⟨ Monotonicity with “Reflexivity of *” ⟩
    R * ⨾ R ⨾ R *
  ⊆⟨ “Left-induction for *” with 
        Subproof for `R ⨾ R ⨾ R * ⊆ R ⨾ R *`:
            R ⨾ R ⨾ R *
          ⊆⟨ Monotonicity with “Left-iteration ⊆ in *” ⟩
            R ⨾ R * 
    ⟩ 
    R ⨾ R *

11.3

Lemma “ExprV evaluation after substitution”:
  ∀ e • evalV s (substV v f e) = evalV (s ⊕′ ⟨v, evalV s f⟩) e
Proof:
  Using “Induction over `ExprV`”:
    Subproof for `∀ u • evalV s (substV v f (Var′ u)) = evalV (s ⊕′ ⟨v, evalV s f⟩) (Var′ u)`:
      For any `u`:
        By cases: `u = v` , `u ≠ v`
          Completeness: By “Excluded middle” and “Definition of ≠”
          Case `u ≠ v`:
              evalV s (substV v f (Var′ u)) 
            =⟨ “Definition of `substV`” with Assumption `u ≠ v` ⟩
              evalV s ( Var′ u )
            =⟨ “Definition of `evalV`” ⟩
              s u 
            =⟨ “Definition of function override” with Assumption `u ≠ v` ⟩  
              (s ⊕′ ⟨v, evalV s f⟩) (u)
            =⟨ “Definition of `evalV`” ⟩  
              evalV (s ⊕′ ⟨v, evalV s f⟩) (Var′ u)

 ╍╍╍ “Definition of `substV`”: v ≠ w ⇒ substV v e (Var′ w) = Var′ w
 ╍╍╍ “Definition of function override”:  (x ≠ z ⇒ (f ⊕′ ⟨ x, y ⟩) z = f z)
╍╍╍ “Definition of `evalV`”:  evalV s (Var′ v) = s v


          Case `u = v`:
              evalV s (substV v f (Var′ u)) 
            =⟨ Assumption `u = v` ⟩
              evalV s (substV v f (Var′ v))
            =⟨ “Definition of `substV`” ⟩   
              evalV s f
            =⟨ “Definition of function override” with Assumption `u = v` ⟩  
              (s ⊕′ ⟨v, evalV s f⟩) (v)  
            =⟨ “Definition of `evalV`” ⟩  
              evalV (s ⊕′ ⟨v, evalV s f⟩) (Var′ v)  
            =⟨ Assumption `u = v` ⟩
              evalV (s ⊕′ ⟨v, evalV s f⟩) (Var′ u)  

╍╍╍ “Definition of `evalV`”:  evalV s (Var′ v) = s v
╍╍╍ “Definition of `substV`”: substV v e (Var′ v) = e
╍╍╍ “Definition of function override”:  (x = z ⇒ (f ⊕′ ⟨ x, y ⟩) z = y)


    Subproof for `∀ n • evalV s (substV v f (Int′ n)) = evalV (s ⊕′ ⟨v, evalV s f⟩) (Int′ n)`:
      For any `n`:
            evalV s (substV v f (Int′ n))
          =⟨ “Definition of `substV`” ⟩
            evalV s (Int′ n)
          =⟨ “Definition of `evalV`” ⟩ 
            n
          =⟨ “Definition of `evalV`” ⟩
            evalV (s ⊕′ ⟨v, evalV s f⟩) (Int′ n)



    Subproof:  ╍╍╍  `(∀ e₁, e₂ ❙ P[e ≔ e₁] ∧ P[e ≔ e₂] • P[e ≔ e₁ +′ e₂])`:
        For any `e1 , e2` satisfying (1)
          `evalV s (substV v f e₁) = evalV (s ⊕′ ⟨v, evalV s f⟩) e₁   ∧
           evalV s (substV v f e₂) = evalV (s ⊕′ ⟨v, evalV s f⟩) e₂`:

            evalV s (substV v f (e₁ +′ e₂)) 
          =⟨ “Definition of `substV`” ⟩
            evalV s (substV v f (e₁) +′ substV v f (e₂)) 
          =⟨ “Definition of `evalV`” ⟩ 
            evalV s (substV v f (e₁))  + evalV s (substV v f (e₂))
          =⟨ Assumption (1) ⟩ 
            (evalV (s ⊕′ ⟨v, evalV s f⟩) e₁)  +  (evalV (s ⊕′ ⟨v, evalV s f⟩) e₂)
          =⟨ “Definition of `evalV`” ⟩ 
            evalV (s ⊕′ ⟨v, evalV s f⟩) (e₁ +′ e₂)
              
        
    Subproof:
        For any `e1 , e2` satisfying (1)
          `evalV s (substV v f e₁) = evalV (s ⊕′ ⟨v, evalV s f⟩) e₁   ∧
           evalV s (substV v f e₂) = evalV (s ⊕′ ⟨v, evalV s f⟩) e₂`:

            evalV s (substV v f (e₁ ·′ e₂)) 
          =⟨ “Definition of `substV`” ⟩
            evalV s (substV v f (e₁) ·′ substV v f (e₂)) 
          =⟨ “Definition of `evalV`” ⟩ 
            evalV s (substV v f (e₁))  · evalV s (substV v f (e₂))
          =⟨ Assumption (1) ⟩ 
            (evalV (s ⊕′ ⟨v, evalV s f⟩) e₁)  ·  (evalV (s ⊕′ ⟨v, evalV s f⟩) e₂)
          =⟨ “Definition of `evalV`” ⟩ 
            evalV (s ⊕′ ⟨v, evalV s f⟩) (e₁ ·′ e₂)

Lemma “Complement of simplee set comprehension”:
  ~ { x ❙ P } = { x ❙ ¬ P }
Proof:
  Using “Set extensionality”:
    For any `e`:
        e ∈ ~ { x ❙ P }
      =⟨ “Set complement” ⟩
        ¬ (e ∈ { x ❙ P })
      =⟨ “Simple membership”⟩
        ¬ P[x ≔ e]
      =⟨ Substitution ⟩
        (¬ P)[x ≔ e]
      =⟨ “Simple membership”⟩
        e ∈ { x ❙ ¬ P }

Lemma “Negation on `Expr𝔹`”:     sat (¬′ b)      =  ~ (sat b)
Proof:
    sat (¬′ b)
  =⟨ “Definition of `sat`” ⟩
    { s ❙ eval𝔹 s (¬′ b) }
  =⟨ “Definition of `eval𝔹`” ⟩
    { s ❙ ¬ (eval𝔹 s b) } 
  =⟨ “Complement of simplee set comprehension” ⟩
    ~ { s ❙ (eval𝔹 s b) }
  =⟨ “Definition of `sat`”⟩
    ~ (sat b)

Lemma “Conjunction on `Expr𝔹`”:  sat (b₁ ∧′ b₂)  =  sat b₁ ∩ sat b₂
Proof:
  Using “Set extensionality”:
      s ∈ sat (b₁ ∧′ b₂)
    ≡⟨“Definition of `sat`” ⟩
      s ∈ { s ❙ eval𝔹 s (b₁ ∧′ b₂) }
    ≡⟨ “Simple membership”⟩
      eval𝔹 s (b₁ ∧′ b₂)
    ≡⟨ “Definition of `eval𝔹`” ⟩
      eval𝔹 s b₁ ∧ eval𝔹 s b₂
    ≡⟨ “Simple membership” ⟩
      s ∈ { s ❙ eval𝔹 s b₁ } ∧ s ∈ { s ❙ eval𝔹 s b₂ }
    ≡⟨ “Definition of `sat`”⟩
      s ∈ sat b₁ ∧ s ∈ sat b₂
    ≡⟨ “Set intersection”⟩
      s ∈ sat b₁ ∩ sat b₂


Lemma “Expr𝔹 evaluation after substitution”:
  ∀ b • eval𝔹 s (subst𝔹 v f b) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b
Proof:
  Using “Induction over `Expr𝔹`”:
    Subproof:
        eval𝔹 s (subst𝔹 v f false′)
      ≡⟨ “Definition of `subst𝔹`”  ⟩
        eval𝔹 s false′
      ≡⟨“Definition of `eval𝔹`”⟩
        false
      ≡⟨ “Definition of `eval𝔹`”⟩
        eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) false′
    Subproof:
        eval𝔹 s (subst𝔹 v f true′)
      =⟨ “Definition of `subst𝔹`” ⟩
        eval𝔹 s true′
      =⟨ “Definition of `eval𝔹`”⟩
        true
      =⟨ “Definition of `eval𝔹`”⟩
        eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) true′
    Subproof:
      For any `e₁, e₂`:
          eval𝔹 s (subst𝔹 v f (e₁ =′ e₂))
        =⟨ “Definition of `subst𝔹`” ⟩
          eval𝔹 s (substV v f e₁ =′ substV v f e₂)
        =⟨ “Definition of `eval𝔹`”⟩
          evalV s (substV v f e₁) = evalV s (substV v f e₂)
        =⟨ “ExprV evaluation after substitution”⟩
          evalV (s ⊕′ ⟨v, evalV s f⟩) e₁ =
          evalV (s ⊕′ ⟨v, evalV s f⟩) e₂
        =⟨“Definition of `eval𝔹`”⟩  
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) (e₁ =′ e₂)
    Subproof:
      For any `b` satisfying “IndHyp”
            `eval𝔹 s (subst𝔹 v f b) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b`:
          eval𝔹 s (subst𝔹 v f (¬′ b))
        =⟨“Definition of `subst𝔹`”⟩
          eval𝔹 s (¬′ (subst𝔹 v f b))
        =⟨ “Definition of `eval𝔹`”⟩
          ¬ (eval𝔹 s (subst𝔹 v f b))
        =⟨ Assumption “IndHyp”⟩
          ¬ (eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b)
        =⟨ “Definition of `eval𝔹`”⟩
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) (¬′ b)             

    Subproof:
      For any `b₁, b₂` satisfying “IndHyp”
             `eval𝔹 s (subst𝔹 v f b₁) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₁ ∧ 
              eval𝔹 s (subst𝔹 v f b₂) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₂`:
          eval𝔹 s (subst𝔹 v f (b₁ ∧′ b₂))
        =⟨ “Definition of `subst𝔹`”⟩
          eval𝔹 s (subst𝔹 v f b₁ ∧′ subst𝔹 v f b₂)
        =⟨ “Definition of `eval𝔹`”⟩
          eval𝔹 s (subst𝔹 v f b₁) ∧ 
          eval𝔹 s (subst𝔹 v f b₂)
        =⟨ Assumption “IndHyp”⟩
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₁ ∧
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₂
        =⟨ “Definition of `eval𝔹`”⟩
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) (b₁ ∧′ b₂)
    Subproof:
      For any `b₁, b₂` satisfying “IndHyp”
             `eval𝔹 s (subst𝔹 v f b₁) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₁ ∧ 
              eval𝔹 s (subst𝔹 v f b₂) = eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₂`:
          eval𝔹 s (subst𝔹 v f (b₁ ∨′ b₂))
        =⟨ “Definition of `subst𝔹`”⟩
          eval𝔹 s (subst𝔹 v f b₁ ∨′ subst𝔹 v f b₂)
        =⟨ “Definition of `eval𝔹`”⟩
          eval𝔹 s (subst𝔹 v f b₁) ∨ 
          eval𝔹 s (subst𝔹 v f b₂)
        =⟨ Assumption “IndHyp”⟩
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₁ ∨
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) b₂
        =⟨ “Definition of `eval𝔹`”⟩
          eval𝔹 (s ⊕′ ⟨v, evalV s f⟩) (b₁ ∨′ b₂)

11.4

Theorem “Partial correctness via ∀”:
  (P ⇒⁅ C ⁆ Q)
  ≡ ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q
Proof:
    (P ⇒⁅ C ⁆ Q)
  ≡⟨ “Partial correctness” ⟩
    ⟦ C ⟧ ⦇ sat P ⦈ ⊆ sat Q
  ≡⟨ “Set inclusion” ⟩
    ∀ s₂ • s₂ ∈ ⟦ C ⟧ ⦇ sat P ⦈ ⇒ s₂ ∈ sat Q
  ≡⟨ “Relational image”⟩
    ∀ s₂ • (∃ s₁ ❙ s₁ ∈ sat P • s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ) ⇒ s₂ ∈ sat Q
  ≡⟨ “Material implication” ⟩
    ∀ s₂ • ¬ (∃ s₁ ❙ s₁ ∈ sat P • s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ) ∨ s₂ ∈ sat Q
  ≡⟨ “Generalised De Morgan” ⟩
    ∀ s₂ • (∀ s₁ ❙ s₁ ∈ sat P • ¬ (s₁ ⦗ ⟦ C ⟧ ⦘ s₂ )) ∨ s₂ ∈ sat Q
  ≡⟨ “Distributivity of ∨ over ∀” ⟩
    ∀ s₂ • ∀ s₁ ❙ s₁ ∈ sat P • ¬ (s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ) ∨ s₂ ∈ sat Q
  ≡⟨ “Material implication” ⟩
    ∀ s₂ • ∀ s₁ ❙ s₁ ∈ sat P • (s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ) ⇒ s₂ ∈ sat Q
  ≡⟨ “Trading for ∀”⟩
    ∀ s₂ • ∀ s₁ • s₁ ∈ sat P ∧ (s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ) ⇒ s₂ ∈ sat Q
  ≡⟨ “Nesting for ∀”, “Dummy list permutation for ∀”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q

Lemma “Relational image under {}”:  {} ⦇ P ⦈ = {}
Proof:
  Using “Set extensionality”:
      y  ∈  {} ⦇ P ⦈
    =⟨ “Definition of ⦇_⦈” ⟩
      y ∈ (Ran (P ◁ {}))  
    ≡⟨ “Membership in `Ran`” ⟩
      (∃ x • x ⦗ (P ◁ {}) ⦘ y )  
    ≡⟨ “Relationship via ◁” ⟩
      (∃ x • x ∈ P ∧ x ⦗ {} ⦘ y  )      
    ≡⟨ “Empty relation” ⟩
      (∃ x • x ∈ P ∧ false  )      
    ≡⟨ “Zero of ∧” ⟩ 
      (∃ x • false)
    ≡⟨ “False ∃ body” ⟩       
      false
    ≡⟨ “Empty set” ⟩ 
      y ∈ {} 

Theorem “Partial correctness of `while true`”:
    P ⇒⁅ while true′ do C od ⁆ Q
Proof:
    P ⇒⁅ while true′ do C od ⁆ Q
  ≡⟨ “Partial correctness via ∀”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦  while true′ do C od  ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q
  ≡⟨ “Semantics of `while`” ⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ (sat true′ ◁ ⟦ C ⟧) * ⩥ sat true′ ⦘ s₂ ⇒ s₂ ∈ sat Q
  ≡⟨ “sat true′” ⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ (𝐔 ◁ ⟦ C ⟧) * ⩥ 𝐔 ⦘ s₂ ⇒ s₂ ∈ sat Q
  =⟨“BC”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ {} ⦘ s₂ ⇒ s₂ ∈ sat Q
  ≡⟨ “Empty relation”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ false ⇒ s₂ ∈ sat Q
  ≡⟨ “ex falso quodlibet”, “Zero of ∧”⟩
    ∀ s₁, s₂ • true
  ≡⟨“Nesting for ∀”, “True ∀ body”⟩
    true

Lemma “BC”: P ⩥ 𝐔 = {}
Proof:
  Using “Relation extensionality”:
    For any `x , y`:
        x ⦗ P ⩥ 𝐔 ⦘ y
      ≡⟨ “Relationship via ⩥” ⟩ 
        x ⦗ P ⦘ y ∧  ¬ (y ∈ 𝐔)
      ≡⟨ “Universal set” ⟩
        x ⦗ P ⦘ y ∧  ¬ (true) 
      ≡⟨ “Definition of `false`” and “Zero of ∧” ⟩ 
        false
      ≡⟨ “Empty relation” ⟩ 
        x ⦗ {} ⦘ y


Theorem “`skip` rule”:  P ⇒⁅ skip ⁆ P
Proof:
    P ⇒⁅ skip ⁆ P
  ≡⟨ “Partial correctness via ∀”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ skip ⟧ ⦘ s₂ ⇒ s₂ ∈ sat P
  ≡⟨ “Semantics of `skip`”⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ 𝕀 ⦘ s₂ ⇒ s₂ ∈ sat P
  ≡⟨ “Identity relation” ⟩
    ∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ = s₂ ⇒ s₂ ∈ sat P
  ≡⟨ “Nesting for ∀”⟩
    ∀ s₁ • ∀ s₂ • s₁ ∈ sat P ∧ s₁ = s₂ ⇒ s₂ ∈ sat P
  ≡⟨ “Trading for ∀”, “One-point rule for ∀”, Substitution⟩
    true
  

Lemma “Relational image under 𝕀”:    𝕀 ⦇ P ⦈ = P
Proof: 
  Using “Set extensionality”:
      y ∈ 𝕀 ⦇ P ⦈
    ≡⟨ “Definition of ⦇_⦈” ⟩
      y ∈ Ran (P ◁ 𝕀)
    ≡⟨ “Membership in `Ran`” ⟩
      ∃ x • x ⦗ P ◁ 𝕀 ⦘ y 
    ≡⟨ “Relationship via ◁” ⟩ 
      ∃ x • x ∈ P ∧ x ⦗ 𝕀 ⦘ y
    ≡⟨ “Relationship via 𝕀” ⟩
      ∃ x • x ∈ P ∧ x = y
    ≡⟨ “Reflexivity of ≡” ⟩ 
      ∃ x • x = y  ∧  x ∈ P 
    ≡⟨ “Trading for ∃” ⟩
      ∃ x ❙ x = y  •  x ∈ P
    ≡⟨ “One-point rule for ∃” and Substitution ⟩    
      y ∈ P

╍╍╍ “One-point rule for ∃”: (∃ x ❙ x = E • P ) ≡ P[x ≔ E]   
╍╍╍ “Definition of ⦇_⦈” “Range of ◁”: R ⦇ A ⦈ = Ran (A ◁ R)
╍╍╍ “Membership in Ran”: y ∈ Ran R ≡ (∃ x • x ⦗ R ⦘ y ) 
╍╍╍  “Relationship via ◁”: x ⦗ A ◁ R ⦘ y ≡ x ∈ A ∧ x ⦗ R ⦘ y
╍╍╍ “∃-Introduction”: P[x ≔ E] ⇒ (∃ x • P )
╍╍╍ “Trading for ∃”: (∃ x ❙ R • P ) ≡ (∃ x • R ∧ P )

Theorem “skip rule”:  P ⇒⁅ skip ⁆ P
Proof:
    P ⇒⁅ skip ⁆ P
  ≡⟨ “Partial correctness” ⟩
    ⟦ skip ⟧ ⦇ sat P ⦈ ⊆ sat P
  ≡⟨ “Semantics of `skip`” ⟩
    𝕀 ⦇ sat P ⦈ ⊆ sat P
  ≡⟨ “Relational image under 𝕀” ⟩  
    sat P ⊆ sat P
  ≡⟨ “Reflexivity of ⊆” ⟩ 
    true

Lemma “Mono of mirror”: A ⊆ B ⇒ R ⦇ A ⦈ ⊆ R ⦇ B ⦈
Proof:
    R ⦇ A ⦈ ⊆ R ⦇ B ⦈
  =⟨“Definition of ⦇_⦈”⟩
    Ran (A ◁ R) ⊆ Ran (B ◁ R)
  ⇐⟨ “Monotonicity of `Ran`” ⟩
    (A ◁ R) ⊆ (B ◁ R)
  ⇐⟨ “Monotonicity of ◁” ⟩
    A ⊆ B

Derived inference rule “Sequence”:
    `P  ⇒⁅ C₁ ⁆  Q`,  `Q  ⇒⁅ C₂ ⁆  R`
   ⊦————————————————————————————————
      `P  ⇒⁅ C₁ ⍮ C₂ ⁆  R`
Proof:
  Assuming (C₁) `P  ⇒⁅ C₁ ⁆  Q` and using with “Partial correctness”,
           (C₂) `Q  ⇒⁅ C₂ ⁆  R` and using with “Partial correctness”:
      P  ⇒⁅ C₁ ⍮ C₂ ⁆  R
    ≡⟨ “Partial correctness” ⟩
      ⟦ C₁ ⍮ C₂ ⟧ ⦇ sat P ⦈ ⊆ sat R
    ≡⟨ “Semantics of ⍮”⟩
      (⟦ C₁ ⟧ ⨾ ⟦ C₂ ⟧) ⦇ sat P ⦈ ⊆ sat R
    ≡⟨ “Relational image under ⨾”⟩
      ⟦ C₂ ⟧ ⦇ (⟦ C₁ ⟧ ⦇ sat P ⦈) ⦈ ⊆ sat R
    ⇐⟨ “Transitivity of ⊆” with “Mono of mirror” with Assumption (C₁) ⟩
      ⟦ C₂ ⟧ ⦇ sat Q ⦈ ⊆ sat R
    ≡⟨ Assumption (C₂)⟩
      true

Lemma “Rel img of union”: (A ∪ B) ⦇ C ⦈ = (A ⦇ C ⦈) ∪ (B ⦇ C ⦈)
Proof:
    (A ∪ B) ⦇ C ⦈
  =⟨ “Definition of ⦇_⦈”⟩
    Ran (C ◁ (A ∪ B))
  =⟨“Distributivity of ◁ over relation union”⟩
    Ran ((C ◁ A) ∪ (C ◁ B))
  =⟨ “Range of union”⟩ 
    Ran (C ◁ A) ∪ Ran (C ◁ B)
  =⟨ “Definition of ⦇_⦈”⟩
    (A ⦇ C ⦈) ∪ (B ⦇ C ⦈)

Lemma “Rel img of ◁”: (A ◁ R) ⦇ B ⦈ = R ⦇ A ∩ B ⦈
Proof:
    (A ◁ R) ⦇ B ⦈
  =⟨ “Definition of ⦇_⦈”⟩
    Ran (B ◁ (A ◁ R))
  =⟨ “Nested ◁”⟩
    Ran ((B ∩ A) ◁ R )
  =⟨ “Definition of ⦇_⦈”⟩
    R ⦇ A ∩ B ⦈

Derived inference rule “Conditional”:

      `B ∧′ P ⇒⁅ C₁ ⁆ Q`,   `¬′ B ∧′ P ⇒⁅ C₂ ⁆ Q`
    ⊦————————————————————————————————————————————
        `P ⇒⁅ if B then C₁ else C₂ fi ⁆ Q`

Proof:
  Assuming (1) `B ∧′ P ⇒⁅ C₁ ⁆ Q` and using with “Partial correctness”,
           (2) `¬′ B ∧′ P ⇒⁅ C₂ ⁆ Q` and using with “Partial correctness”:
      P ⇒⁅ if B then C₁ else C₂ fi ⁆ Q
    =⟨ “Partial correctness” ⟩
      ⟦ if B then C₁ else C₂ fi ⟧ ⦇ sat P ⦈ ⊆ sat Q
    =⟨ “Semantics of `if`” ⟩ 
      ((sat B ◁ ⟦ C₁ ⟧) ∪ (sat B ⩤ ⟦ C₂ ⟧)) ⦇ sat P ⦈ ⊆ sat Q
    =⟨ “Rel img of union” ⟩
      ((sat B ◁ ⟦ C₁ ⟧) ⦇ sat P ⦈) ∪ ((sat B ⩤ ⟦ C₂ ⟧) ⦇ sat P ⦈) ⊆ sat Q
    =⟨ “Definition of ⩤ via ◁” ⟩ 
      ((sat B ◁ ⟦ C₁ ⟧) ⦇ sat P ⦈) ∪ ((~ (sat B) ◁ ⟦ C₂ ⟧) ⦇ sat P ⦈) ⊆ sat Q
    =⟨ “Rel img of ◁”⟩
      (⟦ C₁ ⟧ ⦇ sat B ∩ sat P ⦈) ∪ (⟦ C₂ ⟧ ⦇ ~ (sat B) ∩ sat P ⦈) ⊆ sat Q
    =⟨ “Characterisation of ∪”⟩ 
      (⟦ C₁ ⟧ ⦇ sat B ∩ sat P ⦈) ⊆ sat Q ∧ (⟦ C₂ ⟧ ⦇ ~ (sat B) ∩ sat P ⦈) ⊆ sat Q
    =⟨ “Conjunction on `Expr𝔹`”, “Negation on `Expr𝔹`”⟩
      ⟦ C₁ ⟧ ⦇ sat (B ∧′ P) ⦈ ⊆ sat Q ∧ (⟦ C₂ ⟧ ⦇ sat ( ¬′ B ∧′ P) ⦈) ⊆ sat Q
    =⟨ Assumptions (1) and (2), “Idempotency of ∧”⟩
      true


Derived inference rule “While”:
                 `B ∧′ Q  ⇒⁅ C ⁆  Q`
        ⊦—————————————————————————————————————
          `Q  ⇒⁅ while B do C od ⁆  ¬′ B ∧′ Q`
Proof:
  Assuming “this” `B ∧′ Q  ⇒⁅ C ⁆  Q` and using with “Partial correctness”:
    Side proof for (1)`(sat B ◁ ⟦ C ⟧) ⦇ sat Q ⦈ ⊆ sat Q`:
        (sat B ◁ ⟦ C ⟧) ⦇ sat Q ⦈
      =⟨ “Definition of ⦇_⦈”⟩
        Ran (sat Q ◁ sat B ◁ ⟦ C ⟧)
      =⟨ “Nested ◁”⟩
        Ran ((sat Q ∩ sat B) ◁ ⟦ C ⟧)
      =⟨ “Conjunction on `Expr𝔹`”⟩
        Ran ((sat (Q ∧′ B)) ◁ ⟦ C ⟧)
      =⟨ “Definition of ⦇_⦈”⟩
        ⟦ C ⟧ ⦇ sat (Q ∧′ B) ⦈
      ⊆⟨ Assumption “this” with “Partial correctness” ⟩ 
        sat Q
    Continuing:
        Q  ⇒⁅ while B do C od ⁆  ¬′ B ∧′ Q
      =⟨ “Partial correctness” ⟩
        ⟦ while B do C od ⟧ ⦇ sat Q ⦈ ⊆ sat (¬′ B ∧′ Q)
      =⟨ “Conjunction on `Expr𝔹`”, “Negation on `Expr𝔹`”⟩
        ⟦ while B do C od ⟧ ⦇ sat Q ⦈ ⊆  ~ (sat B) ∩ sat Q
      =⟨ “Semantics of `while`”⟩
        ((sat B ◁ ⟦ C ⟧) * ⩥ sat B) ⦇ sat Q ⦈ ⊆  ~ (sat B) ∩ sat Q
      =⟨ “Relational image under ⩥” ⟩
        (sat B ◁ ⟦ C ⟧) * ⦇ sat Q ⦈  ∩  ~ (sat B) ⊆ ~ (sat B) ∩  sat Q
      ⇐⟨ “Monotonicity of ∩” ⟩
        ((sat B ◁ ⟦ C ⟧) * ⦇ sat Q ⦈) ⊆  sat Q
      =⟨ “Relational image under *” with local property (1) ⟩
        true

Total Correctness


Corollary “Inclusion of `sat`”:
    b₁ ⊑ b₂  ≡  sat b₁ ⊆ sat b₂
Proof:
    b₁ ⊑ b₂
  ≡⟨ “Semantic consequence in `Expr𝔹`” ⟩
    ∀ s : Var → ℤ • eval𝔹 s b₁ ⇒ eval𝔹 s b₂   
  ≡⟨ “Simple membership” ⟩
    ∀ s • s ∈ { s ❙ (eval𝔹 s) b₁ } ⇒ s ∈ { s ❙ (eval𝔹 s) b₂ }
  ≡⟨ “Set inclusion” ⟩
    { s ❙ (eval𝔹 s) b₁ } ⊆ { s ❙ (eval𝔹 s) b₂ }
  ≡⟨ “Definition of `sat`” ⟩
    sat b₁ ⊆ sat b₂

Derived inference rule “Strengthening the precondition”:
    `P  ⊑  Q`,  `Q  ⇒⁅ C ⁆  R`
   ⊦————————————————————————————————
      `P  ⇒⁅ C ⁆  R`
Proof:
  Assuming (1) `P  ⊑  Q` and using with “Inclusion of `sat`” , 
           (2) `Q  ⇒⁅ C ⁆  R` and using with “Partial correctness” :
      P  ⇒⁅ C ⁆  R
    ≡⟨ “Partial correctness” ⟩
      ⟦ C ⟧ ⦇ sat P ⦈ ⊆ sat R
    ⇐⟨ “Transitivity of ⊆” with “Monotonicity of ⦇_⦈” with Assumption (1) ⟩ 
      ⟦ C ⟧ ⦇ sat Q ⦈ ⊆ sat R
    ≡⟨Assumption (2)⟩
      true

Theorem “Distinguishing `Expr𝔹`”:
   s₁ ≠ s₂ ⇒ ∃ b : Expr𝔹 • eval𝔹 s₁ b ≠ eval𝔹 s₂ b
Proof:
  Assuming `s₁ ≠ s₂`:
      ∃ b • eval𝔹 s₁ b ≠ eval𝔹 s₂ b
    ⇐⟨ “∃-Introduction” ⟩ 
      (eval𝔹 s₁ b ≠ eval𝔹 s₂ b) [b ≔ (Int′ v =′ Var′ w)]
    ≡⟨ Substitution ⟩ 
      (eval𝔹 s₁ (Int′ v =′ Var′ w) ≠ eval𝔹 s₂ (Int′ v =′ Var′ w))
    ≡⟨ “Definition of `eval𝔹`” ⟩
      (evalV s₁ (Int′ v) = evalV s₁ (Var′ w)) ≠ (evalV s₂ (Int′ v) = evalV s₂ (Var′ w))
    ≡⟨ “Definition of `evalV`” ⟩
      ( v = s₁ w) ≠ (v = s₂ w)
    
    ≡⟨ ? ⟩
      true

Theorem “Total correctness via ∀”:
  (P ⇒⁅⧼ C ⧽⁆ Q)
  ≡ (∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q)
  ∧ (∀ s₁ ❙ s₁ ∈ sat P • ∃ s₂ • s₁ ⦗ ⟦ C ⟧ ⦘ s₂)
Proof:
    (P ⇒⁅⧼ C ⧽⁆ Q)
  ≡⟨ “Total correctness” ⟩
    (⟦ C ⟧ ⦇ sat P ⦈ ⊆ sat Q)  ∧  sat P ⊆ Dom ⟦ C ⟧
  ≡⟨ “Partial correctness” ⟩
    (P ⇒⁅ C ⁆ Q) ∧ sat P ⊆ Dom ⟦ C ⟧
  ≡⟨ “Partial correctness via ∀” ⟩
    (∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q ) ∧ sat P ⊆ Dom ⟦ C ⟧
  ≡⟨ “Definition of ⊆” ⟩ 
    (∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q ) ∧ (∀ s₁ ❙ s₁ ∈ sat P • s₁ ∈ Dom ⟦ C ⟧ )
  ≡⟨ “Membership in `Dom`” ⟩ 
    (∀ s₁, s₂ • s₁ ∈ sat P ∧ s₁ ⦗ ⟦ C ⟧ ⦘ s₂ ⇒ s₂ ∈ sat Q) ∧ (∀ s₁ ❙ s₁ ∈ sat P • ∃ s₂ • s₁ ⦗ ⟦ C ⟧ ⦘ s₂)

Derived inference rule “Sequence tot. corr.”:
    `P  ⇒⁅⧼ C₁ ⧽⁆  Q`,  `Q  ⇒⁅⧼ C₂ ⧽⁆  R`
   ⊦——————————————————————————————————————
      `P  ⇒⁅⧼ C₁ ⍮ C₂ ⧽⁆  R`
Proof:
  Assuming (1) `P  ⇒⁅⧼ C₁ ⧽⁆  Q` and using with “Total correctness” , 
            ╍╍╍ ⟦ C₁ ⟧ ⦇ sat P ⦈ ⊆ sat Q  ∧  sat P ⊆ Dom ⟦ C₁ ⟧ 
           (2) `Q  ⇒⁅⧼ C₂ ⧽⁆  R` and using with “Total correctness” :
            ╍╍╍ ⟦ C₂ ⟧ ⦇ sat Q ⦈ ⊆ sat R  ∧  sat Q ⊆ Dom ⟦ C₂ ⟧
      P  ⇒⁅⧼ C₁ ⍮ C₂ ⧽⁆  R
    ≡⟨ “Total correctness” ⟩
      ⟦ C₁ ⍮ C₂ ⟧ ⦇ sat P ⦈ ⊆ sat R  ∧  sat P ⊆ Dom ⟦ C₁ ⍮ C₂ ⟧
    ≡⟨ “Semantics of ⍮” ⟩  
      ( ⟦ C₁ ⟧ ⨾ ⟦ C₂ ⟧ ) ⦇ sat P ⦈ ⊆ sat R ∧ sat P ⊆ Dom (⟦ C₁ ⟧ ⨾ ⟦ C₂ ⟧)
    ≡⟨ “Relational image under ⨾” ⟩
      ⟦ C₂ ⟧ ⦇ (⟦ C₁ ⟧ ⦇ sat P ⦈) ⦈   ⊆ sat R ∧ sat P ⊆ Dom (⟦ C₁ ⟧ ⨾ ⟦ C₂ ⟧)
    ⇐⟨ Antitonicity with “Monotonicity of ⦇ ⦈” with assumption (1)⟩
      ⟦ C₂ ⟧ ⦇ sat Q ⦈ ⊆ sat R ∧ sat P ⊆ Dom (⟦ C₁ ⟧ ⨾ ⟦ C₂ ⟧)
    ⇐⟨?⟩
      ⟦ C₂ ⟧ ⦇ sat Q ⦈ ⊆ sat R  ∧  sat Q ⊆ Dom ⟦ C₂ ⟧
    ≡⟨ Assumption (2) ⟩ 
      true

Derived inference rule “Conditional tot. corr.”:

      `B ∧′ P ⇒⁅⧼ C₁ ⧽⁆ Q`,   `¬′ B ∧′ P ⇒⁅⧼ C₂ ⧽⁆ Q`
    ⊦————————————————————————————————————————————
        `P ⇒⁅⧼ if B then C₁ else C₂ fi ⧽⁆ Q`

Proof:
  Assuming (1) `B ∧′ P ⇒⁅⧼ C₁ ⧽⁆ Q` and using with “Total correctness” , 
           (2) `¬′ B ∧′ P ⇒⁅⧼ C₂ ⧽⁆ Q` and using with “Total correctness” :
      P ⇒⁅⧼ if B then C₁ else C₂ fi ⧽⁆ Q
    ≡⟨ “Total correctness” ⟩
      ⟦ if B then C₁ else C₂ fi ⟧ ⦇ sat P ⦈ ⊆ sat Q  ∧  sat P ⊆ Dom ⟦ if B then C₁ else C₂ fi ⟧
    ≡⟨ “Semantics of `if`” ⟩  
      ( (sat B ◁ ⟦ C₁ ⟧) ∪ (sat B ⩤ ⟦ C₂ ⟧) ) ⦇ sat P ⦈ ⊆ sat Q  ∧  sat P ⊆ Dom ((sat B ◁ ⟦ C₁ ⟧) ∪ (sat B ⩤ ⟦ C₂ ⟧))
    ≡⟨ ? ⟩
      ⟦ C₂ ⟧ ⦇ sat (¬′ B ∧′ P) ⦈ ⊆ sat Q ∧ sat (¬′ B ∧′ P) ⊆ Dom ⟦ C₂ ⟧
    ≡⟨ “Total correctness” ⟩ 
      ¬′ B ∧′ P ⇒⁅⧼ C₂ ⧽⁆ Q
    ≡⟨ Assumption (2) ⟩  
      true

Theorem “Deterministic total correctness”:
  (∀ c : Cmd • univalent ⟦ c ⟧) ⇒
  ((P ⇒⁅⧼ C ⧽⁆ Q)   ≡   sat P ⊆ Dom (⟦ C ⟧ ▷ sat Q))
Proof:
  Assuming (A)`(∀ c : Cmd • univalent ⟦ c ⟧)`:
      sat P ⊆ Dom (⟦ C ⟧ ▷ sat Q)
    =⟨ “Bounded domain”⟩ 
      id (sat P) ⊆ (⟦ C ⟧ ▷ sat Q) ⨾ (⟦ C ⟧ ▷ sat Q) ˘
    =⟨ “Converse of ▷”⟩ 
      id (sat P) ⊆ (⟦ C ⟧ ▷ sat Q) ⨾ (sat Q ◁ ⟦ C ⟧ ˘) 
    =⟨ “Domain restriction via ⨾”, “Range restriction via ⨾”⟩ 
      id (sat P) ⊆ ⟦ C ⟧ ⨾ id (sat Q) ⨾ id(sat Q) ⨾ ⟦ C ⟧ ˘
    =⟨“Idempotency of `id`”⟩ 
      id (sat P) ⊆ ⟦ C ⟧ ⨾ id (sat Q) ⨾ ⟦ C ⟧ ˘
    =⟨“Domain- and range-bounded univalent” with Assumption (A)⟩ 
       id (sat P) ⊆ ⟦ C ⟧ ⨾ ⟦ C ⟧ ˘ ∧ id (sat P) ⨾ (⟦ C ⟧ ⨾ id (sat Q)) = id (sat P) ⨾ ⟦ C ⟧
    =⟨ “Bounded domain”⟩ 
       sat P ⊆ Dom ⟦ C ⟧ ∧ id (sat P) ⨾ ⟦ C ⟧ ⨾ id (sat Q) = id (sat P) ⨾ ⟦ C ⟧
    =⟨ “Bounded range”⟩ 
       sat P ⊆ Dom ⟦ C ⟧ ∧ Ran(id (sat P) ⨾ ⟦ C ⟧) ⊆ sat Q
    =⟨ “Range of ⨾”, “Range of `id`”, “Range of ◁”⟩ 
       sat P ⊆ Dom ⟦ C ⟧ ∧ ⟦ C ⟧ ⦇ sat P ⦈ ⊆ sat Q
    =⟨ “Total correctness” ⟩
       (P ⇒⁅⧼ C ⧽⁆ Q)


9.2

Theorem (14.230) “Relationship via ⩥” “Range antirestriction”:
    x ⦗ R ⩥ B ⦘ y  ≡  x ⦗ R ⦘ y ∧ ¬ (y ∈ B)
Proof:
    x ⦗ R ⩥ B ⦘ y
  ≡⟨ “Definition of ⩥” ⟩
    x ⦗ R ∩ (𝐔 × ~ B) ⦘ y
  ≡⟨ “Relation intersection” ⟩
    x ⦗ R ⦘ y ∧ x ⦗ 𝐔 × ~ B ⦘ y
  ≡⟨ “Relationship via ×” ⟩
    x ⦗ R ⦘ y ∧ x ∈ 𝐔 ∧ y ∈ ~ B
  ≡⟨ “Universal set”, “Identity of ∧” ⟩
    x ⦗ R ⦘ y ∧ y ∈ ~ B
  ≡⟨ “Set complement” ⟩
    x ⦗ R ⦘ y ∧ ¬ (y ∈ B)


Theorem (14.231) “Domain of ◁”: Dom (A ◁ R) = A ∩ Dom R
Proof:
  Using “Set extensionality”:
    For any `x`:
        x ∈ Dom (A ◁ R)
      ≡⟨ “Membership in `Dom`” ⟩
        ∃ y • x ⦗ A ◁ R ⦘ y
      ≡⟨ “Relationship via ◁” ⟩
        ∃ y • x ∈ A ∧ x ⦗ R ⦘ y
      ≡⟨ “Symmetry of ∧” ⟩
        ∃ y • x ⦗ R ⦘ y ∧ x ∈ A
      ≡⟨ “Distributivity of ∧ over ∃” ⟩ 
        (∃ y • x ⦗ R ⦘ y ) ∧ x ∈ A
      ≡⟨ “Membership in `Dom`”, “Intersection” ⟩
        x ∈ A ∩ Dom R

Theorem (14.235) “Domain restriction by `Dom`”:  Dom S ◁ S = S
Proof:
  Using “Relation extensionality”:
    For any `x`, `y`:
        x ⦗ Dom S ◁ S ⦘ y
      ≡⟨ “Relationship via ◁” ⟩
        x ∈ Dom S ∧ x ⦗ S ⦘ y
      ≡⟨ “Membership in `Dom`” ⟩
        (∃ z • x ⦗ S ⦘ z) ∧ x ⦗ S ⦘ y
      ≡⟨ Substitution ⟩
        (∃ z • x ⦗ S ⦘ z) ∧ (x ⦗ S ⦘ z)[z ≔ y]
      ≡⟨ “∃-Introduction” with “Implication via ∧” ⟩
        (x ⦗ S ⦘ z)[z ≔ y]
      ≡⟨ Substitution ⟩
        x ⦗ S ⦘ y

Theorem (14.237) “Domain restriction via ⨾”:
    A ◁ R = id A ⨾ R
Proof:
  Using “Relation extensionality”:
    For any `x`, `y`:
        x ⦗ A ◁ R ⦘ y
      ≡⟨ “Domain restriction” ⟩
        x ∈ A ∧ x ⦗ R ⦘ y ╍╍╍ (z ∈ A ∧ z ⦗ R ⦘ y)[z ≔ x] (sub) --> 
      ≡⟨ Substitution ⟩
        (z ∈ A ∧ z ⦗ R ⦘ y)[z ≔ x]
      ≡⟨ “Trading for ∃”, “One-point rule for ∃” ⟩
        ∃ z • x = z ∧ z ∈ A ∧ z ⦗ R ⦘ y
      ≡⟨ “Relationship via `id`” ⟩
        ∃ z • x ⦗ id A ⦘ z ∧ z ⦗ R ⦘ y
      ≡⟨ “Relation composition” ⟩
        x ⦗ id A ⨾ R ⦘ y

Theorem (14.247) “Nested ◁”:  A ◁ (B ◁ R) = (A ∩ B) ◁ R
Proof:
    A ◁ (B ◁ R)
  =⟨ “Definition of ◁” ⟩
    (B ◁ R) ∩ (A × 𝐔)
  =⟨ “Definition of ◁” ⟩
    R ∩ (B × 𝐔) ∩ (A × 𝐔)
  =⟨ “Distributivity of × over ∩” ⟩
    R ∩ ((A ∩ B) × 𝐔)
  =⟨ “Definition of ◁” ⟩
    (A ∩ B) ◁ R

Theorem (14.248) “Nested ⩤”:  A ⩤ (B ⩤ R) = (A ∪ B) ⩤ R
Proof:
    A ⩤ (B ⩤ R)
  =⟨ “Definition of ⩤” ⟩
    A ⩤ (R ∩ (~ B × 𝐔))
  =⟨ “Definition of ⩤” ⟩
    R ∩ (~ B × 𝐔) ∩ (~ A × 𝐔)
  =⟨ “Distributivity of × over ∩” ⟩
    R ∩ ((~ B ∩ ~ A) × 𝐔)
  =⟨ “De Morgan for ∪” ⟩
    R ∩ (~ (B ∪ A) × 𝐔)
  =⟨ “De Morgan for ∪” ⟩
    R ∩ (~ (B ∪ A) × 𝐔)
  =⟨ “Definition of ⩤” ⟩
    (B ∪ A) ⩤ R

Theorem (14.259) “Antitonicity of ⩥”:  A ⊆ B  ⇒  R ⩥ B  ⊆  R ⩥ A
Proof:
  Assuming `A ⊆ B`:
      R ⩥ B
    =⟨“Definition of ⩥” ⟩
      R ∩ (𝐔 × ~ B)
    ⊆⟨ “Monotonicity of ∩” with “Monotonicity of ×” with “Antitonicity of ~” with Assumption `A ⊆ B`⟩
      R ∩ (𝐔 × ~ A)
    =⟨ “Definition of ⩥”⟩
      R ⩥ A

Theorem (14.303) “Relational image of ⨾”:  (R ⨾ S) ⦇ A ⦈ = S ⦇ R ⦇ A ⦈ ⦈
Proof:
  Using “Set extensionality”:
    For any `z`:
        z ∈ (R ⨾ S) ⦇ A ⦈ 
      ≡⟨ “Relational image” ⟩
        ∃ x ❙ x ∈ A • x ⦗ R ⨾ S ⦘ z
      ≡⟨ “Relation composition” ⟩
        ∃ x ❙ x ∈ A • (∃ y • x ⦗ R ⦘ y ∧ y ⦗ S ⦘ z) 
      ≡⟨ “Nesting for ∃” ⟩
        ∃ x • ∃ y ❙ x ∈ A • x ⦗ R ⦘ y ∧ y ⦗ S ⦘ z
      ≡⟨ “Trading for ∃”, “Interchange of dummies for ∃” ⟩
        ∃ y • ∃ x • x ∈ A ∧ x ⦗ R ⦘ y ∧ y ⦗ S ⦘ z
      ≡⟨ “Trading for ∃”, “Distributivity of ∧ over ∃” ⟩
        ∃ y ❙ (∃ x ❙ x ∈ A • x ⦗ R ⦘ y) • y ⦗ S ⦘ z
      ≡⟨ “Relational image” ⟩
        ∃ y ❙ y ∈ R ⦇ A ⦈ • y ⦗ S ⦘ z
      ≡⟨ “Relational image” ⟩
        z ∈ S ⦇ R ⦇ A ⦈ ⦈

Theorem (14.402) “Relation override”:
    x ⦗ R ⊕ S ⦘ y  ≡  (¬ (x ∈ Dom S) ∧ x ⦗ R ⦘ y) ∨ x ⦗ S ⦘ y
Proof:
    x ⦗ R ⊕ S ⦘ y  
  ≡⟨ “Definition of ⊕” ⟩
    x ⦗ (Dom S ⩤ R) ∪ S ⦘ y  
  ≡⟨ “Relation union” ⟩
    x ⦗ (Dom S ⩤ R) ⦘ y ∨ x ⦗ S ⦘ y  
  ≡⟨ “Relationship via ⩤” ⟩
    (¬ (x ∈ Dom S) ∧ x ⦗ R ⦘ y) ∨ x ⦗ S ⦘ y


Theorem (14.302) “Relational image”:  y ∈ R ⦇ A ⦈  ≡  (∃ x ❙ x ∈ A • x ⦗ R ⦘ y)
Proof:
    y ∈ R ⦇ A ⦈
  =⟨ “Definition of ⦇_⦈” ⟩
    y ∈ Ran (A ◁ R)
  =⟨ “Membership in `Ran`” ⟩
    ∃ x • x ⦗ A ◁ R ⦘ y
  =⟨ “Relationship via ◁” ⟩
    ∃ x • x ∈ A ∧ x ⦗ R ⦘ y
  =⟨ “Trading for ∃” ⟩
    ∃ x ❙ x ∈ A • x ⦗ R ⦘ y

9.3

Theorem “Reflexivity of ⨾”:
 reflexive R ⇒ reflexive S ⇒ reflexive (R ⨾ S)
Proof:
 Assuming `reflexive R`, `reflexive S`:
 reflexive (R ⨾ S)
 =⟨ “Definition of reflexivity” ⟩
 � ⊆ (R ⨾ S)
 =⟨ “Identity of ⨾” ⟩
 � ⨾ � ⊆ (R ⨾ S)
 ⇐⟨ “Monotonicity of ⨾” with “Shunting” ⟩
 � ⊆ R ∧ � ⊆ S
 =⟨ Assumption `reflexive R` with “Definition of reflexivity”
 true ∧ � ⊆ S
 =⟨ Assumption `reflexive S` with “Definition of reflexivity”
 true ∧ true
 =⟨ “Idempotency of ∧” ⟩
 true


Theorem “Inverse of ⨾”:
    S₁ is-inverse-of R₁  ∧  S₂ is-inverse-of R₂
  ⇒ (S₂ ⨾ S₁) is-inverse-of (R₁ ⨾ R₂)
Proof:
  Assuming (1) `S₁ is-inverse-of R₁` and using with “Definition of inverse”,
           (2) `S₂ is-inverse-of R₂` and using with “Definition of inverse”:
    Using “Definition of inverse”:
      Subproof:
          (S₂ ⨾ S₁) ⨾ (R₁ ⨾ R₂)
        =⟨ “Associativity of ⨾” ⟩
          S₂ ⨾ (S₁ ⨾ R₁) ⨾ R₂
        =⟨ Assumption (1), “Identity of ⨾” ⟩
          S₂ ⨾ R₂ 
        =⟨ Assumption (2) ⟩
          𝕀
      Subproof:
          (R₁ ⨾ R₂) ⨾ (S₂ ⨾ S₁)
        =⟨ “Associativity of ⨾” ⟩
          R₁ ⨾ (R₂ ⨾ S₂) ⨾ S₁
        =⟨ Assumption (2) ⟩
          R₁ ⨾ 𝕀 ⨾ S₁
        =⟨ “Identity of ⨾”, Assumption (1) ⟩
          𝕀


Theorem “Inverse of 𝕀”:  𝕀 is-inverse-of 𝕀
Proof:
    𝕀 is-inverse-of 𝕀
  ≡⟨ “Definition of inverse” ⟩
    𝕀 ⨾ 𝕀 = 𝕀 ∧ 𝕀 ⨾ 𝕀 = 𝕀
  ≡⟨ “Identity of ⨾”, “Reflexivity of =”, “Idempotency of ∧” ⟩
    true

Theorem “Coreflexivity of ⨾”:
    coreflexive R ⇒ coreflexive S ⇒ coreflexive (R ⨾ S)
Proof:
  Assuming `coreflexive R`, `coreflexive S`:
      coreflexive (R ⨾ S)
    =⟨ “Definition of coreflexivity” ⟩
      (R ⨾ S) ⊆ 𝕀
    =⟨“Identity of ⨾” ⟩
      (R ⨾ S) ⊆ 𝕀 ⨾ 𝕀
    ⇐ ⟨“Monotonicity of ⨾” with “Shunting”⟩
      R ⊆ 𝕀 ∧ S ⊆ 𝕀
    =⟨ Assumption `coreflexive R` with “Definition of coreflexivity”⟩ 
      true ∧ S ⊆ 𝕀
    =⟨ “Identity of ∧” ⟩
      S ⊆ 𝕀
    =⟨ Assumption `coreflexive S` with “Definition of coreflexivity”⟩ 
      true 


9.4

Lemma “Cancellation of ˘”:
    R ˘ = S ˘  ≡  R = S
Proof:
  Using “Mutual implication”:
    Subproof for `R ˘ = S ˘ ⇒ R = S`:
      Assuming `R ˘ = S ˘`:
          R
        =⟨ “Self-inverse of ˘” ⟩
          R ˘ ˘
        =⟨ Assumption `R ˘ = S ˘` ⟩
          S ˘ ˘
        =⟨ “Self-inverse of ˘” ⟩
          S
    Subproof for `R = S ⇒ R ˘ = S ˘`:
      Assuming `R = S`:
          R ˘
        =⟨ Assumption `R = S` ⟩
          S ˘

Theorem “Isotonicity of ˘”: R ⊆ S ≡ R ˘ ⊆ S ˘
Proof:
    R ⊆ S
  ⇒⟨ “Monotonicity of ˘” ⟩
    R ˘ ⊆ S ˘
  ⇒⟨ “Monotonicity of ˘” ⟩
    R ˘ ˘ ⊆ S ˘ ˘
  =⟨ “Self-inverse of ˘” ⟩
    R ⊆ S

Lemma “Definition of symmetry”:
    symmetric R ≡ R ˘ = R
Proof:
    symmetric R
  ≡⟨ “Definition of symmetry” ⟩
    R ˘ ⊆ R
  ≡⟨ “Idempotency of ∧” ⟩
    R ˘ ⊆ R ∧ R ˘ ⊆ R
  ≡⟨ “Isotonicity of ˘” ⟩
    R ˘ ˘ ⊆ R ˘ ∧ R ˘ ⊆ R
  ≡⟨ “Self-inverse of ˘” ⟩
    R ⊆ R ˘ ∧ R ˘ ⊆ R
  ≡⟨ “Mutual inclusion” ⟩
    R ˘ = R

Theorem “Reflexivity of converse”:
    reflexive R ≡ reflexive (R ˘)
Proof:
    reflexive R
  ≡⟨ “Definition of reflexivity” ⟩
    𝕀 ⊆ R
  ≡⟨ “Isotonicity of ˘” ⟩
    𝕀 ˘ ⊆ R ˘
  ≡⟨ “Converse of 𝕀”, “Definition of reflexivity” ⟩
    reflexive (R ˘)

Theorem “Symmetry of converse”:
    symmetric R ≡ symmetric (R ˘)
Proof:
    symmetric R
  ≡⟨ “Definition of symmetry” ⟩
    R ˘ ⊆ R
  ≡⟨ “Isotonicity of ˘” ⟩
    R ˘ ˘ ⊆ R ˘
  ≡⟨ “Self-inverse of ˘”, “Definition of symmetry” ⟩
    symmetric (R ˘)

Theorem “𝕀 is mapping”: mapping 􀀅
Proof:
  Using “Definition of mappings”:
    Subproof:
        univalent 𝕀
      =⟨ “Definition of univalence” ⟩
        𝕀 ˘ ⨾ 𝕀 ⊆ 𝕀
      =⟨ “Converse of 𝕀” ⟩
        𝕀 ⨾ 𝕀 ⊆ 𝕀
      =⟨ “Identity of ⨾” ⟩
        𝕀 ⊆ 𝕀
      =⟨ “Reflexivity of ⊆” ⟩
        true
    Subproof:
        total 𝕀
      =⟨ “Definition of totality” ⟩
         𝕀 ⊆ 𝕀 ⨾ 𝕀 ˘
      =⟨ “Converse of 𝕀”, “Identity of ⨾”, “Reflexivity of ⊆” ⟩
        true

Theorem “Composition of mappings”:
    mapping F ∧ mapping G ⇒ mapping (F ⨾ G)
Proof:
  Assuming (F) `mapping F` and using with “Definition of mappings”,
           (G) `mapping G` and using with “Definition of mappings”:
    Using “Definition of mappings”:
      Subproof: ╍╍╍ proof for univalent
          (F ⨾ G) ˘ ⨾ (F ⨾ G)
        =⟨ “Converse of ⨾” ⟩
          (G ˘ ⨾ F ˘) ⨾ (F ⨾ G)
        ⊆⟨ “Monotonicity of ⨾” with “Monotonicity of ⨾” with Assumption (F)⟩ 
          G ˘ ⨾ 𝕀 ⨾ G
        ⊆⟨ “Identity of ⨾”, Assumption (G) ⟩
          𝕀
      Subproof: ╍╍╍ proof for total
          𝕀
        ⊆⟨ Assumption (F) ⟩
          F ⨾ F ˘
        =⟨ “Identity of ⨾” ⟩
          F ⨾ 𝕀 ⨾ F ˘
        ⊆⟨ “Monotonicity of ⨾” with “Monotonicity of ⨾” with Assumption (G)⟩ 
          (F ⨾ G) ⨾ (G ˘ ⨾ F ˘)
        =⟨ “Converse of ⨾” ⟩
          (F ⨾ G) ⨾ (F ⨾ G) ˘

Theorem “total in univalent”:
     total R ⇒ univalent S ⇒ R ⊆ S ⇒ R = S
Proof:
  Assuming `total R`, `univalent S`, `R ⊆ S`:
    Using “Mutual inclusion” with assumption `R ⊆ S`:
        S
      =⟨ “Identity of ⨾” ⟩
        𝕀 ⨾ S
      ⊆⟨ “Monotonicity of ⨾” with Assumption `total R` with “Definition of totality” ⟩
        (R ⨾ R ˘) ⨾ S
      ⊆⟨ “Monotonicity of ⨾” with “Monotonicity of ⨾” with “Monotonicity of ˘” with Assumption `R ⊆ S`⟩
        (R ⨾ S ˘) ⨾ S
      ⊆⟨ “Monotonicity of ⨾” with Assumption `univalent S` with “Definition of univalence”⟩
        R ⨾ 𝕀
      =⟨ “Identity of ⨾”⟩
        R


Theorem “Inverse of mapping”:
    mapping f ⇒ g is-inverse-of f ⇒ g = f ˘
Proof:
  Assuming `mapping f` and using with “Definition of mappings”,
           `g is-inverse-of f` and using with “Definition of inverse”:
    Using “Mutual inclusion”:
      Subproof:
          g
        =⟨ “Identity of ⨾” ⟩
          g ⨾ 𝕀
        ⊆⟨ “Monotonicity of ⨾” with Assumption `mapping f` ⟩
          g ⨾ f ⨾ f ˘
        =⟨ “Definition of inverse” with Assumption `g is-inverse-of f`⟩ 
          𝕀 ⨾ f ˘
        =⟨ “Identity of ⨾” ⟩
          f ˘
      Subproof:
          f ˘
        =⟨ “Identity of ⨾” ⟩
          f ˘ ⨾ 𝕀
        =⟨ Assumption `g is-inverse-of f` ⟩
          f ˘ ⨾ f ⨾ g ╍╍╍ why does order matter here? ask 
        ⊆⟨ “Monotonicity of ⨾” with Assumption `mapping f`, “Identity of ⨾”⟩  
          g

9.5

Theorem “Weakening for ∩”: Q ∩ R ⊆ Q  ∧  Q ∩ R ⊆ R
Proof:
    Q ∩ R ⊆ Q ∧ Q ∩ R ⊆ R
  =⟨ “Characterisation of ∩” ⟩
    Q ∩ R ⊆ Q ∩ R
  =⟨ “Reflexivity of ⊆” ⟩
    true

Corollary “Symmetry of ∩”: Q ∩ R = R ∩ Q
Proof:
  Using “Mutual inclusion”:
    Subproof for `Q ∩ R ⊆ R ∩ Q`:
      By “Symmetry of ∩”
    Subproof for `R ∩ Q ⊆ Q ∩ R`:
      By “Symmetry of ∩”

Theorem “Inclusion via ∩”: Q ⊆ R ≡ Q ∩ R = Q
Proof:
    Q ∩ R = Q
  =⟨ “Mutual inclusion” ⟩
    Q ∩ R ⊆ Q ∧ Q ⊆ Q ∩ R
  =⟨ “Weakening for ∩”, “Identity of ∧” ⟩
    Q ⊆ Q ∩ R
  =⟨ “Characterisation of ∩” ⟩
    Q ⊆ Q ∧ Q ⊆ R
  =⟨ “Reflexivity of ⊆”, “Identity of ∧” ⟩
    Q ⊆ R

Theorem “Converse of ∩”: (R ∩ S) ˘ ⊆ R ˘ ∩ S ˘
Proof:
    (R ∩ S) ˘ ⊆ R ˘ ∩ S ˘
  =⟨ “Characterisation of ∩” ⟩
    (R ∩ S) ˘ ⊆ R ˘ ∧ (R ∩ S) ˘ ⊆ S ˘
  =⟨ “Isotonicity of ˘” ⟩
    (R ∩ S) ⊆ R ∧ (R ∩ S) ⊆ S
  =⟨ “Weakening for ∩” ⟩
    true

Theorem “Converse of ∩”:     (R ∩ S) ˘  =  R ˘ ∩ S ˘
Proof:
  Using “Indirect Relation Equality from below”:
    For any `Q`:
        Q ⊆ (R ∩ S) ˘ ≡ Q ⊆ R ˘ ∩ S ˘
      ≡⟨ “Isotonicity of ˘” ⟩
        Q ˘ ⊆ (R ∩ S) ˘ ˘ ≡ Q ⊆ R ˘ ∩ S ˘
      ≡⟨ “Self-inverse of ˘” ⟩
        Q ˘ ⊆ (R ∩ S) ≡ Q ⊆ R ˘ ∩ S ˘
      ≡⟨ “Characterisation of ∩” ⟩
        Q ˘ ⊆ R ∧ Q ˘ ⊆ S ≡ Q ⊆ R ˘ ∩ S ˘
      ≡⟨ “˘ connection” ⟩
        Q ⊆ R ˘ ∧ Q ⊆ S ˘ ≡ Q ⊆ R ˘ ∩ S ˘
      ≡⟨ “Characterisation of ∩”, “Reflexivity of ≡” ⟩
        true

Theorem “Antisymmetry of converse”:  antisymmetric R  ≡  antisymmetric (R ˘)
Proof:
    antisymmetric R
  ≡⟨ “Definition of antisymmetry” ⟩
    R ∩ R ˘ ⊆ Id
  ≡⟨ “Self-inverse of ˘” ⟩
    R ˘ ∩ R ˘ ˘ ⊆ Id
  ≡⟨ “Definition of antisymmetry” ⟩
    antisymmetric (R ˘)

9.6

Theorem “Hesitation”: R ⊆ R ⨾ R ˘ ⨾ R
Proof:
    R
  =⟨ “Idempotency of ∩” ⟩
    R ∩ R
  =⟨ “Identity of ⨾” ⟩
    R ⨾ 𝕀 ∩ R
  ⊆⟨ “Modal rule” ⟩
    R ⨾ (𝕀 ∩ R ˘ ⨾ R)
  ⊆⟨ “Monotonicity of ⨾” with “Weakening for ∩” ⟩
    R ⨾ R ˘ ⨾ R

Theorem “PER factoring”:
    symmetric Q ⇒ transitive Q ⇒  Q ⨾ R ∩ Q = Q ⨾ (R ∩ Q)
Proof:
  Assuming `symmetric Q` and using with “Definition of symmetry”,
           `transitive Q` and using with “Definition of transitivity”:
      Q ⨾ (R ∩ Q)
    ⊆⟨ “Sub-distributivity of ⨾ over ∩” ⟩
      Q ⨾ R ∩ Q ⨾ Q
    ⊆⟨ Monotonicity with Assumption `transitive Q` ⟩ 
      Q ⨾ R ∩ Q
    ⊆⟨ “Modal rule” ⟩
      Q ⨾ (R ∩ Q ˘ ⨾ Q)
    ⊆⟨ Monotonicity with Assumption `symmetric Q` ⟩
      Q ⨾ (R ∩ Q ⨾ Q)
    ⊆⟨ Monotonicity with Assumption `transitive Q` ⟩
      Q ⨾ (R ∩ Q)

Theorem “Reflexive implies total”:
    reflexive R ⇒ total R
Proof:
    reflexive R
  =⟨ “Definition of reflexivity” ⟩
    𝕀 ⊆ R
  =⟨ “Monotonicity of ˘” with “Definition of ⇒ via ∧” ⟩
    𝕀 ⊆ R ∧ 𝕀 ˘ ⊆ R ˘
  ⇒⟨ “Monotonicity of ⨾” with “Shunting” ⟩
    𝕀 ⨾ 𝕀 ˘ ⊆ R ⨾ R ˘
  =⟨ “Converse of 𝕀”, “Identity of ⨾” ⟩
    𝕀 ⊆ R ⨾ R ˘
  =⟨ “Definition of totality” ⟩
    total R

Theorem “Idempotency from symmetric and transitive”:
    symmetric R ⇒ transitive R ⇒ idempotent R
Proof:
  Assuming `symmetric R` and using with “Definition of symmetry”,
           `transitive R` and using with “Definition of transitivity”:
    Using “Definition of idempotency”:
      Subproof for `R ⨾ R = R`:
          R ⨾ R
        ⊆⟨ Assumption `transitive R` ⟩
          R
        ⊆⟨ “Hesitation” ⟩
          R ⨾ (R ˘ ⨾ R)
        ⊆⟨ Monotonicity with Assumption `symmetric R` ⟩
          R ⨾ (R ⨾ R)
        ⊆⟨ Monotonicity with Assumption `transitive R` ⟩
          R ⨾ R

Theorem “Right-distributivity of ⨾ with univalent over ∩”:
    univalent F  ⇒  F ⨾ (R ∩ S) = F ⨾ R ∩ F ⨾ S
Proof:
  Assuming `univalent F` and using with “Definition of univalence”:
      F ⨾ (R ∩ S)
    ⊆⟨ “Sub-distributivity of ⨾ over ∩” ⟩
      F ⨾ R ∩ (F ⨾ S) ╍╍╍ ⨾ associates to the right
    ⊆⟨ “Modal rule” ⟩
      F ⨾ (R ∩ F ˘ ⨾ F ⨾ S)
    ⊆⟨ Monotonicity with Assumption `univalent F` ⟩
      F ⨾ (R ∩ 𝕀 ⨾ S)
    =⟨ “Identity of ⨾” ⟩
      F ⨾ (R ∩ S)

Theorem “Swapping mapping across ⊆”:
    mapping F  ⇒  (R ⨾ F ⊆ S  ≡  R ⊆ S ⨾ F ˘)
Proof:
  Assuming `mapping F` and using with “Definition of mappings”:
      R ⨾ F ⊆ S
    ⇒⟨ “Monotonicity of ⨾” ⟩
      R ⨾ F ⨾ F ˘ ⊆ S ⨾ F ˘
    ⇒⟨ Antitonicity with assumption `mapping F` ⟩
      R ⨾ 𝕀 ⊆ S ⨾ F ˘
    =⟨ “Identity of ⨾” ⟩
      R ⊆ S ⨾ F ˘
    ⇒⟨ “Monotonicity of ⨾” ⟩
      R ⨾ F ⊆ S ⨾ F ˘ ⨾ F
    ⇒⟨ Monotonicity with assumption `mapping F` ⟩
      R ⨾ F ⊆ S ⨾ 𝕀
    =⟨ “Identity of ⨾” ⟩
      R ⨾ F ⊆ S

10.1

Theorem “Distributivity of composition with univalent over ∩”:
   univalent F  ⇒  F ⨾ (R ∩ S) = F ⨾ R ∩ F ⨾ S
Proof:
  Assuming `univalent F` and using with “Univalence”:
    Using “Relation extensionality”:
      For any `x`, `z`:
          x ⦗ F ⨾ R ∩ F ⨾ S ⦘ z
        =⟨ “Relation intersection”, “Relation composition” ⟩
          (∃ y₁ • x ⦗ F ⦘ y₁ ∧ y₁ ⦗ R ⦘ z) ∧ (∃ y₂ • x ⦗ F ⦘ y₂ ∧
        =⟨ “Distributivity of ∧ over ∃” ⟩
          ∃ y₁ • ∃ y₂ • x ⦗ F ⦘ y₁ ∧ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₂ ∧ y₂
        =⟨ Assumption `univalent F`, “Identity of ∧” ⟩
          ∃ y₁ • ∃ y₂ • (x ⦗ F ⦘ y₁ ∧ x ⦗ F ⦘ y₂ ⇒ y₂ = y₁)
          ∧ x ⦗ F ⦘ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₂ ⦗ S ⦘ z
        =⟨ ?, “Strong modus ponens” ⟩
          ∃ y₁ • ∃ y₂ • y₂ = y₁ ∧ x ⦗ F ⦘ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₂
        =⟨ “Trading for ∃” ⟩
          ∃ y₁ • ∃ y₂ ❙ y₂ = y₁ • x ⦗ F ⦘ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₂
        =⟨ “One-point rule for ∃” ⟩
          ∃ y₁ • (x ⦗ F ⦘ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₂ ⦗ S ⦘ z)[y₂ ≔ y₁]
        =⟨ Substitution ⟩
          ∃ y₁ • x ⦗ F ⦘ y₁ ⦗ R ⦘ z ∧ x ⦗ F ⦘ y₁ ⦗ S ⦘ z
        =⟨ “Idempotency of ∧” ⟩
          ∃ y₁ • x ⦗ F ⦘ y₁ ∧ y₁ ⦗ R ⦘ z ∧ y₁ ⦗ S ⦘ z
        =⟨ “Relation intersection” ⟩
          ∃ y₁ • x ⦗ F ⦘ y₁ ∧ y₁ ⦗ R ∩ S ⦘ z
        =⟨ “Relation composition” ⟩
          x ⦗ F ⨾ (R ∩ S) ⦘ z

Theorem “Surjective range restriction”:
    surjective (R ▷ B)  ≡  surjective R ∧ B = 𝐔
Proof:
    surjective (R ▷ B)
  ≡⟨ “Surjectivity” ⟩
    ∀ b • (∃ a • a ⦗ R ▷ B ⦘ b)
  ≡⟨ “Relationship via ▷” ⟩
    ∀ b • (∃ a • a ⦗ R ⦘ b ∧ b ∈ B)
  ≡⟨ “Distributivity of ∧ over ∃” ⟩
    ∀ b • (∃ a • a ⦗ R ⦘ b) ∧ b ∈ B
  ≡⟨ “Distributivity of ∀ over ∧” ⟩
    (∀ b • (∃ a • a ⦗ R ⦘ b)) ∧ (∀ b • b ∈ B)
  ≡⟨ “Surjectivity” ⟩
    surjective R ∧ (∀ b • b ∈ B)
  ≡⟨ “Identity of ≡” ⟩
    surjective R ∧ (∀ b • b ∈ B ≡ true)
  ≡⟨ “Universal set” ⟩
    surjective R ∧ (∀ b • b ∈ B ≡ b ∈ 𝐔)
  ≡⟨ “Set extensionality” ⟩
    surjective R ∧ B = 𝐔


Theorem “@ via relational image”:
      univalent f  ∧  x ∈ Dom f
   ⇒  f ⦇ { x } ⦈ = { f @ x }
Proof:
  Assuming (1) `univalent f ∧ x ∈ Dom f`:
    Using “Set extensionality”:
      For any `y`:
          y ∈ f ⦇ { x } ⦈
        ≡⟨ “Relational image” ⟩
          ∃ z ❙ z ∈ { x } • z ⦗ f ⦘ y
        ≡⟨ “Singleton set membership” ⟩
          ∃ z ❙ z = x • z ⦗ f ⦘ y
        ≡⟨ “One-point rule for ∃”, Substitution ⟩
          x ⦗ f ⦘ y
        ≡⟨ “Partial-function application” with Assumption (1) ⟩
          y = f @ x
        ≡⟨ “Singleton set membership” ⟩
          y ∈ { f @ x }


Theorem “Membership in domain of ⨾”:
     x ∈ Dom (R ⨾ S)
  ≡  x ∈ Dom R  ∧  (∃ y ❙ x ⦗ R ⦘ y • y ∈ Dom S)
Proof:
     x ∈ Dom (R ⨾ S)
  ≡⟨ “Membership in `Dom`” ⟩
     ∃ z • x ⦗ R ⨾ S ⦘ z
  ≡⟨ “Relation composition” ⟩
     ∃ z • ∃ y • x ⦗ R ⦘ y ∧ y ⦗ S ⦘ z
  ≡⟨ “Interchange of dummies for ∃” ⟩
     ∃ y • ∃ z • x ⦗ R ⦘ y ∧ y ⦗ S ⦘ z
  ≡⟨ “Distributivity of ∧ over ∃” ⟩
    (∃ y • x ⦗ R ⦘ y ∧ (∃ z • y ⦗ S ⦘ z))
  ≡⟨ “Definition of ⇒ via ∧” with “Body weakening for ∃” ⟩
    (∃ y • x ⦗ R ⦘ y) ∧ (∃ y • x ⦗ R ⦘ y ∧ (∃ z • y ⦗ S ⦘ z))
  ≡⟨ “Trading for ∃” ⟩
    (∃ y • x ⦗ R ⦘ y) ∧ (∃ y ❙ x ⦗ R ⦘ y • (∃ z • y ⦗ S ⦘ z))
  ≡⟨ “Membership in `Dom`” ⟩
    x ∈ Dom R ∧ (∃ y ❙ x ⦗ R ⦘ y • y ∈ Dom S)

Theorem “Partial-function application of ⨾”:
      univalent f  ∧  univalent g  ∧  x ∈ Dom (f ⨾ g)
   ⇒  (f ⨾ g) @ x = g @ (f @ x)
Proof:
  Assuming `univalent f`, `univalent g`, `x ∈ Dom (f ⨾ g)`:
    Side proof for `x ∈ Dom f`:
      By assumption `x ∈ Dom (f ⨾ g)` with “Membership in domain of
    Side proof for `f @ x ∈ Dom g`:
        x ∈ Dom (f ⨾ g) — This is an assumption
      ⇒⟨ “Membership in domain of ⨾”, “Weakening” ⟩
        ∃ y ❙ x ⦗ f ⦘ y • y ∈ Dom g
      ≡⟨ “Partial-function application” with assumption `univalent f`
           and local property `x ∈ Dom f` ⟩
        ∃ y ❙ y = f @ x • y ∈ Dom g
      ≡⟨ “One-point rule for ∃”, substitution ⟩
        f @ x ∈ Dom g
    Side proof for “U” `univalent (f ⨾ g)`:
      By “Univalence of composition” with assumptions `univalent f` and `univalent g`⟩
  Continuing:
      (f ⨾ g) @ x = g @ (f @ x)
    ≡⟨ “Partial-function application” with local property “U”
          and assumption `x ∈ Dom (f ⨾ g)` ⟩
      x ⦗ f ⨾ g ⦘ g @ (f @ x)
    ≡⟨ “Relation composition” ⟩
      ∃ y • x ⦗ f ⦘ y ∧ y ⦗ g ⦘ g @ (f @ x)
    ≡⟨ “Partial-function application” with assumption `univalent f`⟩
         and local property `x ∈ Dom f`, “Trading for ∃” ⟩   
      ∃ y ❙ y = f @ x • y ⦗ g ⦘ g @ (f @ x)
    ≡⟨ “One-point rule for ∃”, substitution ⟩
      f @ x ⦗ g ⦘ g @ (f @ x) 
    ≡⟨ “Relationship with @” with assumption `univalent g`
          and local property `f @ x ∈ Dom g` ⟩
      true


Theorem “Injectivity and @”:
     univalent f  ∧  injective f  ∧
     x₁ ∈ Dom f   ∧  x₂ ∈ Dom f
  ⇒  (f @ x₁ = f @ x₂   ≡   x₁ = x₂)
Proof:
  Assuming `univalent f`, `x₁ ∈ Dom f`, `x₂ ∈ Dom f`:
    Assuming (1) `injective f` and using with “Injectivity”:
        x₁ = x₂
      ⇒⟨ “Leibniz” ⟩
        (f @ z)[z ≔ x₁] = (f @ z)[z ≔ x₂]
      ≡⟨ Substitution ⟩
        f @ x₁ = f @ x₂
      ≡⟨ “Partial-function application” with
           Assumption `x₂ ∈ Dom f` and
             Assumption `univalent f` ⟩
        x₂ ⦗ f ⦘ f @ x₁
      ≡⟨ “Identity of ∧” ⟩
        true ∧ x₂ ⦗ f ⦘ f @ x₁
      ≡⟨ “Partial-function application” with 
           Assumption `x₂ ∈ Dom f` with Assumption `x₁ ∈ Dom f` with
             Assumption `univalent f` ⟩
        x₁ ⦗ f ⦘ f @ x₁ ∧ x₂ ⦗ f ⦘ f @ x₁
      ⇒⟨ Assumption `injective f` ⟩
        x₁ = x₂

10.2

Theorem “Addition in **”: R ** (i + j) = R ** i ⨾ R ** j
Proof:
  By induction on `i : ℕ`:
    Base case:
        R ** (0 + j) = R ** 0 ⨾ R ** j
      =⟨ “Definition of + for 0” ⟩
        R ** j = R ** 0 ⨾ R ** j
      =⟨ “Identity of ⨾”, “Definition of **” ⟩
        R ** 0 ⨾ R ** j = R ** 0 ⨾ R ** j
      =⟨ “Reflexivity of =” ⟩ 
        true
    Induction step:
        R ** (suc i + j)
      =⟨ “Definition of + for `suc`” ⟩
        R ** (suc (i + j))
      =⟨ “Definition of **” ⟩
        R ⨾ R ** (i + j)
      =⟨ Induction hypothesis ⟩
        R ⨾ R ** i ⨾ R ** j
      =⟨ “Definition of **” ⟩
        R ** suc i ⨾ R ** j


Theorem “Characterisation of `_*`: Expanding”:  R ⊆ R *
Proof:
     R *
  =⟨ “Definition of `_*`” ⟩
     ⋃ i : ℕ • R ** i
  =⟨ “Zero of ∨” ⟩
     ⋃ i : ℕ ❙ true ∨ i = 1 • R ** i
  =⟨ “Range split for ⋃” ⟩
     (⋃ i : ℕ ❙ true • R ** i) ∪ (⋃ i : ℕ ❙ i = 1 • R ** i)
  =⟨ “One-point rule for ⋃”, Substitution ⟩
     (⋃ i : ℕ ❙ true • R ** i) ∪ R ** 1
  ⊇⟨ “Weakening for ∪”, “Right-identity of **” ⟩
     R

Theorem “Characterisation of `_*`: Reflexivity”:
    reflexive (R *)
Proof:
  Using “Definition of reflexivity”:
      R *
    =⟨ “Definition of `_*`” ⟩
      ⋃ i : ℕ • R ** i
    =⟨ “Zero of ∨” ⟩
      ⋃ i : ℕ ❙ true ∨ i = 0 • R ** i
    =⟨ “Range split for ⋃” ⟩
      (⋃ i : ℕ ❙ true • R ** i) ∪ (⋃ i : ℕ ❙ i = 0 • R ** i)
    =⟨ “One-point rule for ⋃”, Substitution ⟩
      (⋃ i : ℕ ❙ true • R ** i) ∪ R ** 0
    ⊇⟨ “Weakening for ∪”, “Definition of **” ⟩
      𝕀

Theorem “Characterisation of _*: Transitivity”:
   transitive (R *)
Proof: 
      transitive (R *)
    ≡⟨“Definition of transitivity”⟩
      R * ⨾ R * ⊆ R *
    ≡⟨ “Definition of `_*`”⟩
      (⋃ i : ℕ • R ** i) ⨾  (⋃ j : ℕ • R ** j) ⊆  (⋃ k : ℕ • R ** k)
    ≡⟨“Distributivity of ⨾ over ⋃” ⟩
      (⋃ i : ℕ • R ** i ⨾  (⋃ j : ℕ • R ** j)) ⊆  (⋃ k : ℕ • R ** k)
    ≡⟨“Distributivity of ⨾ over ⋃”⟩
      (⋃ i : ℕ • ( ⋃ j : ℕ • R ** i ⨾ R ** j) )  ⊆  (⋃ k : ℕ • R ** k)
    ≡⟨“Characterisation of ⋃”⟩
      ∀ i : ℕ • ∀ j : ℕ • R ** i ⨾ R ** j ⊆ (⋃ k : ℕ • R ** k)

  Proof for this:
    For any `i : ℕ`, `j : ℕ`:
        R ** i ⨾ R ** j
      =⟨ “Addition in **”⟩
        R ** (i + j)
      ⊆⟨“Weakening for ∪”⟩
        (⋃ k : ℕ • R ** k) ∪ R ** (i + j)
      =⟨“One-point rule for ⋃”, Substitution⟩
        (⋃ k : ℕ ❙ true • R ** k) ∪ (⋃ k : ℕ ❙ k = i + j • R ** k)
      =⟨“Range split for ⋃”⟩
        (⋃ k : ℕ ❙ true ∨ k = i + j • R ** k)
      =⟨“Zero of ∨”⟩
        (⋃ k : ℕ • R ** k)

Theorem “Characterisation of `_*`: Expansion of powers”:
    R ⊆ S  ⇒  reflexive S  ⇒  transitive S  ⇒ R ** i ⊆ S
Proof:
  Assuming `R ⊆ S`:
    Assuming `reflexive S` and using with “Definition of reflexivity”:
      Assuming `transitive S` and using with “Definition of transitivity”:
          By induction on `i : ℕ`:
            Base case:
                R ** 0
              =⟨“Definition of **”⟩
                𝕀
              ⊆⟨ Assumption `reflexive S` with “Definition of reflexivity”⟩
                S
            Induction step:
                R ** suc i
              =⟨“Definition of **”⟩
                R ⨾ R ** i
              ⊆⟨“Monotonicity of ⨾” with Induction hypothesis⟩
                R ⨾ S
              ⊆⟨“Monotonicity of ⨾” with Assumption `R ⊆ S`⟩
                S ⨾ S
              ⊆⟨ Assumption `transitive S`⟩
                S

Theorem “Characterisation of `_*`: Minimality”:
    R ⊆ S  ⇒  reflexive S  ⇒  transitive S  ⇒ R * ⊆ S
Proof:
  Assuming `R ⊆ S`, `reflexive S`, `transitive S`:
      R * ⊆ S
    ≡⟨ “Definition of `_*`” ⟩
      (⋃ i : ℕ • R ** i) ⊆ S
    ≡⟨ “Characterisation of ⋃” ⟩
      ∀ i : ℕ • R ** i ⊆ S
    ≡⟨ “Characterisation of `_*`: Expansion of powers” with assumptions `R ⊆ S` and `reflexive S`
         and `transitive S` ⟩
      ∀ i : ℕ • true
    ≡⟨ “True ∀ body” ⟩
      true


out in   
T    S  Atleast 1
U    I  Atmost 1
M    B  exactly 1



7.3

Theorem “Non-empty-sequence decomposition”:
    xs ≠ 𝜖  ⇒  xs = head xs ◃ tail xs
Proof:
  By induction on `xs : Seq A`:
    Base case:
        𝜖 ≠ 𝜖 ⇒ 𝜖 = head 𝜖 ◃ tail 𝜖
      ≡⟨ “Irreflexivity of ≠” ⟩
        false ⇒ 𝜖 = head 𝜖 ◃ tail 𝜖
      ≡⟨ “ex falso quodlibet” ⟩
        true
    Induction step:
      For any `x`:
          (x ◃ xs) ≠ 𝜖 ⇒ (x ◃ xs) = head (x ◃ xs) ◃ tail (x ◃ xs)
        ≡⟨ “Cons is not empty” ⟩
          true ⇒ (x ◃ xs) = head (x ◃ xs) ◃ tail (x ◃ xs)
        ≡⟨ “Left-identity of ⇒” ⟩
          (x ◃ xs) = head (x ◃ xs) ◃ tail (x ◃ xs)
        ≡⟨ “Definition of `head`”, “Definition of `tail`” ⟩
          (x ◃ xs) = x ◃ xs
        ≡⟨ “Reflexivity of =” ⟩
          true


Theorem “Initialisation for `elem`”:
      true ╍╍╍ Precondition
    ⇒⁅ xs := xs₀ ⍮
       b := false ⁆
      ∃ ys • ys ⌢ xs = xs₀ ∧ (b ≡ x ∈ ys)
Proof:
    true
  ≡⟨ “Idempotency of ∧” ⟩
    true ∧ true
  ≡⟨ “Left-identity of ⌢”, “Reflexivity of =” ⟩
    𝜖 ⌢ xs₀ = xs₀ ∧ true
  ≡⟨ “Reflexivity of ≡” ⟩
    𝜖 ⌢ xs₀ = xs₀ ∧ (false ≡ false)
  ≡⟨ “Membership in 𝜖” ⟩
    𝜖 ⌢ xs₀ = xs₀ ∧ (false ≡ x ∈ 𝜖)
  ≡⟨ Substitution ⟩
    (ys ⌢ xs₀ = xs₀ ∧ (false ≡ x ∈ ys))[ys ≔ 𝜖]
  ⇒⟨ “∃-Introduction” ⟩
    ∃ ys • ys ⌢ xs₀ = xs₀ ∧ (false ≡ x ∈ ys)
  ⇒⁅ xs := xs₀ ⁆ ⟨ “Assignment” with substitution ⟩
    ∃ ys • ys ⌢ xs = xs₀ ∧ (false ≡ x ∈ ys)
  ⇒⁅ b := false ⁆ ⟨ “Assignment” with substitution ⟩
    ∃ ys • ys ⌢ xs = xs₀ ∧ (b ≡ x ∈ ys)

Theorem “Postcondition for `elem`”:
      ¬ (xs ≠ 𝜖) ∧ (∃ ys • ys ⌢ xs = xs₀ ∧ (b ≡ x ∈ ys)) ╍╍╍ negation of while
    ⇒ (b ≡ x ∈ xs₀)
Proof:
  Assuming (1) `¬ (xs ≠ 𝜖)` and using with “Negation of ≠”, ╍╍╍ assumption1 says
           (2) `(∃ ys • ys ⌢ xs = xs₀ ∧ (b ≡ x ∈ ys))`:
    Assuming witness `ys` satisfying (3) `ys ⌢ xs = xs₀ ∧ (b ≡ x ∈ ys)`:
        x ∈ xs₀
      ≡⟨ Assumption (3) ⟩
        x ∈ ys ⌢ xs
      ≡⟨ Assumption (1) ⟩
        x ∈ ys ⌢ 𝜖
      ≡⟨ “Right-identity of ⌢” ⟩
        x ∈ ys
      ≡⟨ Assumption (3) ⟩
        b

Lemma “snoc-cat”: xs ▹ y ⌢ ys = xs ⌢ y ◃ ys
Proof:
  By induction on `xs : Seq A`:
    Base case:
        𝜖 ▹ y ⌢ ys
      =⟨ “Definition of ▹ for 𝜖” ⟩
        (y ◃ 𝜖) ⌢ ys
      =⟨ “Mutual associativity of ◃ with ⌢”, “Left-identity of ⌢”⟩ 
        𝜖 ⌢ y ◃ ys
    Induction step:
      For any `x`:
          (x ◃ xs) ▹ y ⌢ ys
        =⟨ “Definition of ▹ for ◃”, “Mutual associativity of ◃ with ⌢”⟩
          x ◃ (xs ▹ y ⌢ ys)
        =⟨ Induction hypothesis ⟩
          x ◃ (xs ⌢ y ◃ ys)
        =⟨ “Mutual associativity of ◃ with ⌢” ⟩
          (x ◃ xs) ⌢ y ◃ ys

Theorem “Invariant for `elem`”:
      xs ≠ 𝜖 ∧ (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))
    ⇒⁅
          if head xs = x
          then b := true
          else skip
          fi ⍮
          xs := tail xs
      ⁆
      (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))
Proof:
    xs ≠ 𝜖 ∧ (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))
  ⇒⁅
          if head xs = x
          then b := true
          else skip
          fi
    ⁆ ⟨ Subproof:
          Using “Conditional”:
            Subproof:
                head xs = x ∧ xs ≠ 𝜖 ∧ (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))
              ⇒⟨ Subproof:
                   Assuming (1) `head xs = x`,
                            (2) `xs ≠ 𝜖`,
                            (3) `(∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))`:
                     Assuming witness `us` satisfying
                       (4) `us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us)` by Assumption (3):
                         ∃ us • us ⌢ tail xs = xs₀ ∧ (x ∈ us)
                       ⇐⟨ “∃-Introduction” ⟩
                         (us ⌢ tail xs = xs₀ ∧ (x ∈ us))[us ≔ us]
                       ≡⟨ Substitution ⟩
                         us ▹ head xs ⌢ tail xs = xs₀ ∧ (x ∈ us)
                       ≡⟨ Assumption (1) ⟩
                         us ▹ head xs ⌢ tail xs = xs₀ ∧ (x ∈ (us))
                       ≡⟨ “Membership in ▹” ⟩
                         us ▹ head xs ⌢ tail xs = xs₀ ∧ (x ∈ us)
                       ≡⟨ “Reflexivity of =”, “Zero of ∨”, “Identity of ∧” ⟩ 
                         us ▹ head xs ⌢ tail xs = xs₀
                       ≡⟨ “snoc-cat” ⟩
                         us ⌢ head xs ◃ tail xs = xs₀
                       ≡⟨ “Non-empty-sequence decomposition” with Assumption (2) ⟩
                         us ⌢ xs = xs₀
                       ≡⟨ Assumption (4) ⟩
                         true
                ⟩
                ∃ us • us ⌢ tail xs = xs₀ ∧ (x ∈ us)
              ≡⟨ “Identity of ≡” ⟩
                ∃ us • us ⌢ tail xs = xs₀ ∧ (true ≡ x ∈ us)
              ⇒⁅ b := true ⁆ ⟨ “Assignment” with Substitution ⟩
                (∃ us • us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us))
            Subproof:
                ¬ (head xs = x) ∧ xs ≠ 𝜖 ∧ (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))
              ⇒⟨ Subproof:
                    Assuming (1) `¬ (head xs = x)`,
                             (2) `xs ≠ 𝜖`,
                             (3) `∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us)`:
                       
                        Assuming witness `us` satisfying
                          (4) `us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us)` by Assumption (3):
                            ∃ us • us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us)
                          ⇐⟨ “∃-Introduction” ⟩
                            (us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us))[us ≔ us]
                          ≡⟨ Substitution ⟩
                            us ▹ head xs ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us)
                          ≡⟨ “Membership in ▹” ⟩
                            us ▹ head xs ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us)
                          ≡⟨ Assumption (1), “Identity of ∨” ⟩
                            us ▹ head xs ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us)
                          ≡⟨ “snoc-cat” ⟩
                            us ⌢ head xs ◃ tail xs = xs₀ ∧ (b ≡ x ∈ us)
                          ≡⟨ “Non-empty-sequence decomposition” with Assumption (2)⟩
                            us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us)
                          ≡⟨ Assumption (4) ⟩
                            true
                 
                ⟩
                (∃ us • us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us))
              ⇒⁅ skip ⁆ ⟨ “skip” ⟩
                (∃ us • us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us))
    ⟩
    (∃ us • us ⌢ tail xs = xs₀ ∧ (b ≡ x ∈ us))
  ⇒⁅ xs := tail xs ⁆ ⟨ “Assignment” with Substitution ⟩
    (∃ us • us ⌢ xs = xs₀ ∧ (b ≡ x ∈ us))

Fact (CondCorr1):
      true              ╍╍╍ Precondition
    ⇒⁅
        if m ≤ 10
        then skip
        else m := 0
        fi
      ⁆
      m ≤ 10           ╍╍╍ Postcondition
Proof:
    true               ╍╍╍ Precondition
  ⇒⁅ if m ≤ 10 then skip else m := 0 fi ⁆ ⟨ Subproof:
      Using “Conditional”:
        Subproof:  ╍╍╍ (subproof goal is obvious from calculation)
            true ∧ m ≤ 10           ╍╍╍ Precondition for `then`
          ≡  ⟨ “Identity of ∧” ⟩
            m ≤ 10
          ⇒⁅ skip ⁆  ⟨ “skip” ⟩
            m ≤ 10                  ╍╍╍ Postcondition
        Subproof:  ╍╍╍ (subproof goal is obvious from calculation)
            true ∧ ¬ (m ≤ 10)       ╍╍╍ Precondition for `else`
          ⇒  ⟨ “Weakening” ⟩
            true
          ≡  ⟨ Fact `0 ≤ 10` ⟩
            0 ≤ 10
          ⇒⁅ m := 0 ⁆  ⟨ “Assignment” with substitution ⟩
            m ≤ 10                  ╍╍╍ Postcondition
    ⟩
    m ≤ 10             ╍╍╍ Postcondition
